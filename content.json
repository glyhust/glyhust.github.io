{"meta":{"title":"gly的学习博客","subtitle":"既是学习记录 又是技术分享","description":"learn","author":"gong luyang","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2022-04-28T09:15:08.000Z","updated":"2022-04-28T10:35:54.346Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2022-04-28T09:17:24.000Z","updated":"2022-04-28T10:36:35.287Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"webserver","date":"2022-05-29T06:44:46.000Z","updated":"2022-05-29T06:59:56.252Z","comments":true,"path":"webserver/index.html","permalink":"http://example.com/webserver/index.html","excerpt":"","text":""}],"posts":[{"title":"master模块","slug":"master模块","date":"2022-05-20T10:01:21.000Z","updated":"2022-05-29T06:17:49.591Z","comments":true,"path":"2022/05/20/master模块/","link":"","permalink":"http://example.com/2022/05/20/master%E6%A8%A1%E5%9D%97/","excerpt":"整体概述master模块是分布式缓存系统的管理中心，需要同时与多个client和cache server交互，并且根据接收到的数据进行不同的逻辑处理。在master主函数中，新建多个线程分别处理不同的业务：接收来自cache server的心跳包和client的指令，并做出相应处理；检测cache心跳包计数是否持续增加；向从master定时发送心跳包。","text":"整体概述master模块是分布式缓存系统的管理中心，需要同时与多个client和cache server交互，并且根据接收到的数据进行不同的逻辑处理。在master主函数中，新建多个线程分别处理不同的业务：接收来自cache server的心跳包和client的指令，并做出相应处理；检测cache心跳包计数是否持续增加；向从master定时发送心跳包。 基础知识master数据收发采用socket编程、epoll函数IO多路复用功能和多线程编程，在master端实时监听前来建立连接的client和cache server。其中client需要与master建立通信，请求最新的cache列表，而cache则定时向master发送心跳包。 cache心跳包检测master端维护了已建立连接的cache server列表，根据cache server会定时循环向master发送心跳包的特点，内部维护一个unordered_map结构，接收到cache心跳包时，便计数+1。因此可以比较在经过一段时候后，cache server列表的心跳包计数是否都有所增加，以此判断cache的存活状态，若计数不再增加可判断其已关闭，从cache server列表中删除此服务器，并通知其它服务器更新数据。 master容灾设计主master和从master，主master定时循环向从master发送心跳包，从master通过对心跳包计数以判断主master存活情况，当其故障时，从master接替工作，并通知cache server列表中的所有服务器。 核心代码分析cache心跳包检测123456789101112131415161718192021222324252627282930void* heartstate(void*)&#123; while(1) &#123; if(cachestatemap.size()&gt;0) &#123; precachestatemap=cachestatemap; delayms(1500); for(auto it=cachestatemap.begin();it!=cachestatemap.end();it++) &#123; auto itt=precachestatemap.find(it-&gt;first); if(itt!=precachestatemap.end()) &#123; if(it-&gt;second&lt;=itt-&gt;second) &#123; psshutport=it-&gt;first; psshutip=heartip; if(passive_shutdown_flag==0) &#123; if(psshutport!=shutport) passive_shutdown_flag=1; &#125; &#125; else if(it-&gt;second&gt;1000) it-&gt;second=0; &#125; &#125; &#125; &#125;&#125; 建立cachestatemap维护cache心跳包的计算，循环检测，延时1.5后，所有cache的心跳包计数是否有所增加，若未增加时，判断其已被动关闭,此时将passive_shutdown_flag标志置1，并将被动关闭的cache服务器的IP和port保存至psshutport和psshutip中，供后续逻辑处理流程使用。 master容灾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void* masterupdata(void*)&#123; json heartbeat_json; struct sockaddr_in serv_addr; signal(SIGPIPE,SIG_IGN); bzero(&amp;serv_addr,sizeof(serv_addr)); socklen_t serv_addr_len; serv_addr.sin_family=AF_INET; inet_pton(AF_INET,SPAREMASTER_IP,&amp;serv_addr.sin_addr.s_addr); serv_addr.sin_port=htons(SPAREMASTER_PORT); int cfd=Socket_connect(true,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); while(1) &#123; int n; heartbeat_json=updatamaster(); string buf=heartbeat_json.dump(); buf+=&quot;\\0&quot;; n=Write(cfd,(char*)buf.data(),buf.length()); if(n&lt;0) cfd=Socket_connect(false,(struct sockaddr*)&amp;serv_addr,sizeof(serv_addr)); delayms(100); &#125;&#125;void *masterstate(void*)&#123; while(master_recovery==0) &#123; if(masterstatemap.size()&gt;0) &#123; premasterstatemap=masterstatemap; delayms(1500); for(auto iter = masterstatemap.begin(); iter != masterstatemap.end(); iter++) &#123; auto iterr = premasterstatemap.find(iter-&gt;first); if(iterr!=premasterstatemap.end()) &#123; if(iter-&gt;second &lt;= iterr-&gt;second) &#123; for(int i=0;i&lt;IPportlist.size();i++) &#123; string IPnow=IPportlist[i].substr(0,9); string Portnow=IPportlist[i].substr(10,4); struct sockaddr_in serv_addr; socklen_t serv_addr_len; signal(SIGPIPE, SIG_IGN); bzero(&amp;serv_addr,sizeof(serv_addr)); serv_addr.sin_family = AF_INET; inet_pton(AF_INET, IPnow.c_str(), &amp;serv_addr.sin_addr.s_addr); serv_addr.sin_port = htons(atoi(Portnow.c_str())); int cfd = Socket_connect(true, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); int flags=fcntl(cfd,F_GETFL,0); fcntl(cfd,F_SETFL,flags|O_NONBLOCK); string buf1 = refreshmaster().dump(); buf1+=&quot;\\0&quot;; int n=0; n = Write(cfd, (char *)buf1.data(), buf1.length()+1); while(n&lt;0) &#123; cfd = Socket_connect(false, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); n = Write(cfd, (char *)buf1.data(), buf1.length()+1); &#125; Close(cfd); &#125; IPportlist.clear(); master_recovery=1; &#125; &#125; &#125; &#125; &#125;&#125; 主master模块创建新线程运行masterupdata函数，定时循环向从master发送心跳包。从master模块创建新线程运行masterstate函数，通过维护masterstatemap结构对主master心跳包计数，延时1.5s，判断心跳包计数是否有所增加，当未增加，判断此时主master已故障，因此遍历cache server列表，向内所有服务器发送类型为REFLESH_MASTER的json数据包，通知更新master的IP地址和端口号。 master逻辑处理IO多路复用1234567891011121314151617181920int openmax=1000;int num=0;char buf[BUFSIZ],str[openmax];struct sockaddr_in saddr,caddr;struct epoll_event tep,ep[openmax];int listen_num=10;int server_fd=Socket(AF_INET,SOCK_STREAM,0);int opt=1;setsockopt(server_fd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt));bzero(&amp;saddr,sizeof(saddr));saddr.sin_family=AF_INET;saddr.sin_port=htons(MASTER_PORT);saddr.sin_addr.s_addr=inet_addr(MASTER_IP);int ret=Bind(server_fd,(struct sockaddr*)&amp;saddr,sizeof(saddr));ret=Listen(server_fd,listen_num);int efd=Epoll_create(openmax);tep.events=EPOLLIN|EPOLLET;tep.data.fd=server_fd;int res=Epoll_ctl(efd,EPOLL_CTL_ADD,server_fd,&amp;tep);cout&lt;&lt;&quot;等待客户端连接...&quot;&lt;&lt;endl; 通过socket、bind、listen函数创建socket套接字，并将其加入epoll函数，监听事件发生。 新连接接入12345678910if(ep[i].data.fd==server_fd)&#123; socklen_t clilen=sizeof(caddr); int client_fd=Accept(server_fd,(struct sockaddr*)&amp;caddr,&amp;clilen); auto flag=fcntl(client_fd,F_GETFL); fcntl(client_fd,F_SETFL,flag|O_NONBLOCK); tep.events=EPOLLIN|EPOLLOUT|EPOLLET; tep.data.fd=client_fd; res=Epoll_ctl(efd,EPOLL_CTL_ADD,client_fd,&amp;tep);&#125; 当监听事件文件描述符有IO响应时，代表有新连接（cache server或者client）接入，此时调用accept函数接收对端连接，并将其加入epoll函数中监听。 逻辑处理 类型为DISTRIBUTION_REQUEST时，代表是client发来的拉取cache分布请求，master则调用Distributionresquest函数，其内部向client发送类型为DISTRIBUTION_RESPOND的json数据包，包含了master维护的cache server列表。1234567891011121314151617181920if(info[&quot;type&quot;]==DISTRIBUTION_REQUEST) Distributionresquest(sockfd);void Distributionresquest(int clie_fd)&#123; pthread_rwlock_rdlock(&amp;rw_lock); json data,listip; vector&lt;string&gt; dataip; int size=IPportlist.size(); listip[&quot;type&quot;]=DISTRIBUTION_RESPOND; for(int i=0;i&lt;size;i++) &#123; dataip.push_back(IPportlist[i]); &#125; data[&quot;iplist&quot;]=dataip; listip[&quot;data&quot;]=data; string str_out=listip.dump(); str_out+=&quot;\\0&quot;; Write(clie_fd,(char*)str_out.data(),str_out.length()+1); pthread_rwlock_unlock(&amp;rw_lock);&#125; 类型为SHUTDOWN_CACHE时，代表是接收到的主动关闭cache服务器指令，此时将json数据包内需要关闭的cache列表保存到shutipnow和shutportnow结构中，并将相关标志位置1。12345678910111213else if(info[&quot;type&quot;]==SHUTDOWN_CACHE)&#123; vector&lt;string&gt; userdata=info[&quot;data&quot;][&quot;iplist&quot;]; for(int i=0;i&lt;userdata.size();i++) &#123; ipport_pair temp=get_ipport(userdata[i]); shutipnow.push_back(temp.ip); shutportnow.push_back(to_string(temp.port)); &#125; shut_cache_size=shutportnow.size(); cache_shutdown=1; cache_shutdown_type=1;&#125; 类型为HEART_BEAT时，代表接收到了cache的心跳包，此时将心跳包的地址、状态保存下来，将心跳包计数+1，如果状态为false，则表示该cache主动关闭，将cache_shutdown_type标志置2。1234567891011121314else if(info[&quot;type&quot;]==HEART_BEAT)&#123; string heartdata=info[&quot;data&quot;][&quot;iplist&quot;]; bool heartstate=info[&quot;data&quot;][&quot;state&quot;]; ipport_pair temp=get_ipport(heartdata); heartip=temp.ip; heartport=to_string(temp.port); auto it=cachestatemap.find(heartport); if(it!=cachestatemap.end()) (it-&gt;second++); if(heartstate==false) cache_shutdown_type=2; 通过cache_shutdown_type标志判断是否需要关闭发送此心跳包的cache服务器，当标志为1时，表示处于主动关闭状态，判断cache地址是否出现在主动关闭cache列表中，如果出现，则将其保存在shutport和shutip中；当标志为2时，表示处于被动关闭状态，此时直接将cache地址保存在shutport和shutip中。123456789101112131415if(cache_shutdown_type==1)&#123; auto it1=find(shutportnow.begin(),shutportnow.end(),heartport); if(it1!=shutportnow.end()) shutport=*it1; auto it2=find(shutipnow.begin(),shutipnow.end(),heartip); if(it2!=shutipnow.end()) shutip=*it2;&#125;else if(cache_shutdown_type==2)&#123; shutport=heartport; shutip=heartip; cache_shutdown=1;&#125; 在portlist中寻找，判断心跳包的cache是否出现过，如果未出现过，还要判断是否出现在主动关闭cache列表中，防止待关闭的cache发生重连现象。当它出现在主动关闭cache列表中时，将cache_shutdown_type标志置1，后续对标志进行判断，如果为0时，将cache地址加入到维护的各类列表中；标志为1时，重置标志后不做其它处理。12345678910111213141516171819202122232425262728293031323334auto result=find(Portlist.begin(),Portlist.end(),atoi(heartport.c_str()));if(result==Portlist.end())&#123; if(reconnect_count&lt;reconnect_maxnum) &#123; auto itt=find(shutportnow.begin(),shutportnow.end(),heartport); if(itt!=shutportnow.end()) cache_shutdown_done=1; reconnect_count++; &#125; else &#123; cache_shutdown_done=0; reconnect_count=0; &#125; switch(cache_shutdown_done) &#123; case 0: IPlist.push_back(heartip); Portlist.push_back(atoi(heartport.c_str())); IPportlist.push_back(heartdata); cachemap.emplace(heartport,0); cachemapshut.emplace(heartport,0); cachestatemap.emplace(heartport,0); masterupdatemap.emplace(heartport,0); expan_flag=1; break; case 1: cache_shutdown_done=0; break; default: break; &#125;&#125; 当expan_flag标志为1时，表示有新cache加入，需要向其发送更新节点信息，查找cache地址是否出现在cachemap中，当出现并且计数为0时，向其发送更新节点信息，并将计数置1，然后增加cache_flesh_count计数，但计数等于cachemap大小时，表示已向所有节点发送更新信息，然后将expan_flag标志置0，cache_flesh_count计数归0，然后重置cachemap中所有cache计数。1234567891011121314151617181920212223if(expan_flag==1)&#123; vector&lt;string&gt;().swap(shutportnow); vector&lt;string&gt;().swap(shutipnow); auto it=cachemap.find(heartport); if(it!=cachemap.end()) &#123; if(it-&gt;second==0) &#123; it-&gt;second=1; cache_flesh_count++; refreship(sockfd); &#125; &#125; if(cache_flesh_count==cachemap.size()) &#123; expan_flag=0; cache_flesh_count=0; for(auto&amp; v:cachemap) v.second=0; &#125;&#125; 当cache地址等于待关闭cache地址且cache_shutdown_type标志为1时，代表此时cache在主动关闭cache列表中，此时将其地址从各类列表中删除，然后调用refreship函数向其关闭节点命令，并且计数。当计数等于主动关闭cache列表大小时，代表所有主动关闭cache均已关闭，此时将相关标志位重置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758if(shutport==heartport&amp;&amp;cache_shutdown==1)&#123; for(auto it=IPlist.begin();it!=IPlist.end();it++) &#123; if(*it==shutip) &#123; IPlist.erase(it); break; &#125; &#125; for(auto it=Portlist.begin();it!=Portlist.end();it++) &#123; if(*it==atoi(shutport.c_str())) &#123; Portlist.erase(it); break; &#125; &#125; for(auto it=IPportlist.begin();it!=IPportlist.end();it++) &#123; if(*it==heartdata) &#123; IPportlist.erase(it); break; &#125; &#125; auto it1=cachemap.find(heartport); if(it1!=cachemap.end()) cachemap.erase(it1); auto it2=cachemapshut.find(heartport); if(it2!=cachemapshut.end()) cachemapshut.erase(it2); auto it3=cachestatemap.find(heartport); if(it3!=cachestatemap.end()) cachestatemap.erase(it3); auto it4=precachestatemap.find(heartport); if(it4!=precachestatemap.end()) precachestatemap.erase(it4); auto it5=masterupdatemap.find(heartport); if(it5!=masterupdatemap.end()) masterupdatemap.erase(it5); refreship(sockfd); cache_shutdown_count++; flag8=1; reconnect_maxnum=20; shutport=&quot;&quot;; shutip=&quot;&quot;; if((cache_shutdown_type==1||cache_shutdown_type==2)&amp;&amp;(cache_shutdown_count==shut_cache_size&amp;&amp;flag8==1)) &#123; cache_shutdown_count=0; cache_shutdown=0; allcache_shutdown_down=1; cache_shutdown_done=1; cache_shutdown_type=0; flag8=0; &#125;&#125; 当passive_shutdown_flag标志为1时，表示此时cache进入被动关闭状态，将其地址从各类列表中删除。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748else if(passive_shutdown_flag==1)&#123; for(auto it=IPlist.begin();it!=IPlist.end();it++) &#123; if(*it==psshutip) &#123; IPlist.erase(it); break; &#125; &#125; for(auto it=Portlist.begin();it!=Portlist.end();it++) &#123; if(*it==atoi(psshutport.c_str())) &#123; Portlist.erase(it); break; &#125; &#125; string temp=psshutip+&quot;:&quot;+psshutport; for(auto it=IPportlist.begin();it!=IPportlist.end();it++) &#123; if(*it==temp) &#123; IPportlist.erase(it); break; &#125; &#125; auto it1=cachemap.find(psshutport); if(it1!=cachemap.end()) cachemap.erase(it1); auto it2=cachemapshut.find(psshutport); if(it2!=cachemapshut.end()) cachemapshut.erase(it2); auto it3=cachestatemap.find(psshutport); if(it3!=cachestatemap.end()) cachestatemap.erase(it3); auto it4=precachestatemap.find(psshutport); if(it4!=precachestatemap.end()) precachestatemap.erase(it4); auto it5=masterupdatemap.find(psshutport); if(it5!=masterupdatemap.end()) masterupdatemap.erase(it5); allcache_shutdown_down=1; cache_shutdown_done=1; reconnect_maxnum=20; flag8=0;&#125; 当allcache_shutdown_done标志为1时，表示所有需要关闭的cache服务均已关闭，此时需要向其它cache服务器发送刷新节点命令，通过cachemapshut结构保存是否发送标志，未发送置将标志置1，计数增加后调用refleship函数向其发送刷新列表指令，当计数等于cachemapshut结构大小时，表示发送完毕，此时重置相关标志位。123456789101112131415161718192021if(allcache_shutdown_down==1&amp;&amp;flag8==0)&#123; auto it=cachemapshut.find(heartport); if(it!=cachemapshut.end()) &#123; if(it-&gt;second==0) &#123; it-&gt;second=1; num2++; refreship(sockfd); &#125; &#125; if(num2==cachemapshut.size()) &#123; allcache_shutdown_down=0; passive_shutdown_flag=0; num2=0; for(auto&amp; v:cachemapshut) v.second=0; &#125;&#125;","categories":[{"name":"分布式缓存","slug":"分布式缓存","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"master","slug":"master","permalink":"http://example.com/tags/master/"}]},{"title":"学习博客","slug":"首页","date":"2022-05-20T05:01:21.000Z","updated":"2022-05-29T09:48:27.256Z","comments":true,"path":"2022/05/20/首页/","link":"","permalink":"http://example.com/2022/05/20/%E9%A6%96%E9%A1%B5/","excerpt":"","text":"分布式缓存项目实现基于C++的分布式缓存系统，设计了多Master、多Cache Server以及若干Client并存的分布式缓存架构，能够具有基础的数据读写、分布获取、状态上报功能，同时具备容灾能力。 功能 单个Cache server采用LRU机制保存指定数量的key，并主动淘汰多余的key，同时使用基于epoll和线程池的架构高并发地进行数据收发。 Cache server使用一致哈希算法实现负载均衡，并且会定时向Master发送心跳包以通知自身存活情况。 Master检测到新的Cache server接入时，向所有其它服务器发送扩容指令和新的节点分布列表，各服务器接到指令后通过一致哈希算法将数据转移到新的Cache server。 Master发送缩容指令和新的节点分布列表，接到指定的服务器通过一致哈希算法将数据转移到其它Cache server，最后自动关闭。 Master检测到某个Cache server没有发送心跳包后，向其它节点发送节点更新指令和新的节点分布列表，其它服务器收到指令后将所有备份数据通过一致哈希算法转移到其各自新的对应Cache server上。 Client能生成随机数据并写入Cache server，或者根据key向其对应的Cache server服务器请求value值，当请求超时时，向Master端请求最新的节点分布。Cache server收到数据后会将数据发送到备份Cache server上进行备份处理。 主Master向从Master定时发送心跳包，当从Master检测到主Master停止工作时，会主动通知所有Cache server节点连接到新的Master，接替工作。 博客导航 缓存淘汰策略-LRU 通信格式及辅助函数 一致性哈希 cache模块—数据读写 cache模块—心跳包 client模块 master模块 WebServer项目使用C++语言在Linux环境下搭建轻量级Web服务器 功能 结合线程池、socket套接字、epoll函数实现多线程的并发模型，通过标志位切换LT&#x2F;ET模式、Reactor&#x2F;模拟Proactor模式 结合主状态机、从状态机解析HTTP请求报文，可以处理GET和POST请求，返回服务器图片、视频资源 使用服务器内部数据库保存用户名、登录密码，实现用户通过浏览器进行注册、登录功能 基于有序链表实现定时器，关闭超时的非活跃连接 结合单例模式和阻塞队列实现异步写日志模式，记录服务器的运行状态 博客导航 main主函数 自封装锁 线程池 数据库连接池 日志系统 定时器 http处理类 WebServer类","categories":[],"tags":[]},{"title":"client模块","slug":"client模块","date":"2022-05-16T10:01:21.000Z","updated":"2022-05-29T06:22:56.558Z","comments":true,"path":"2022/05/16/client模块/","link":"","permalink":"http://example.com/2022/05/16/client%E6%A8%A1%E5%9D%97/","excerpt":"整体概述client需要与master和cache server之间交互，其中与master的交互是需要请求cache server列表来更新本地的cache serve列表，与cache server的交互则主要有两个功能：一是随机产生key和对应的value，发送给cache server；二是根据key向对应的cache server请求其相应的value数据。","text":"整体概述client需要与master和cache server之间交互，其中与master的交互是需要请求cache server列表来更新本地的cache serve列表，与cache server的交互则主要有两个功能：一是随机产生key和对应的value，发送给cache server；二是根据key向对应的cache server请求其相应的value数据。 基础知识master交互client需要通过与master进行交互，更新本地的cache server列表，请求分布有三种触发情况： 创建client时没有给定初始cache server分布 本地cache server缓存超时 与某个cache server读写时发现其不可用 cache交互client可以向cache写{key，value}数据，还可以根据key向其对应的cache server请求相应的value数据。 核心代码分析client初始化12345678910Client::Client()&#123; DistributionRequest();&#125;Client::Client(vector&lt;string&gt; iplist)&#123; alliplist.swap(iplist); hash.RefreshIPList(alliplist); time(&amp;start);&#125; client有两种构造函数，当未提供初始cache server列表时，需要向master请求分布，当给定初始列表时，直接根据列表和一致性哈希算法构造哈希环。 请求cache分布123456789101112131415161718192021222324252627282930313233343536void Client::DistributionRequest()&#123; int n,nwrite; ipport_pair masterip=get_ipport(MASTER_IP); json client_to_master=Writejs(DISTRIBUTION_REQUEST); do &#123; n=ConnectServ(masterip,mastercfd); if(n!=0) &#123; Close(mastercfd); masterip=get_ipport(MASTER_IP_BACKUP); n=ConnectServ(masterip,mastercfd); if(n!=0) &#123; perr_exit(&quot;connection to master failed&quot;); &#125; &#125; nwrite=WriteData(mastercfd,client_to_master); &#125;while(nwrite&lt;0); json jsin=ReadData(mastercfd); if(jsin[&quot;type&quot;]!=DISTRIBUTION_RESPOND) perr_exit(&quot;distribution request returns fault&quot;); alliplist=jsin[&quot;data&quot;][&quot;iplist&quot;].get&lt;vector&lt;string&gt;&gt;(); if(alliplist.empty()) perr_exit(&quot;invalid distribution&quot;); hash.RefreshIPList(alliplist); time(&amp;start); cout&lt;&lt;&quot;distribution request once&quot;&lt;&lt;endl; Close(mastercfd);&#125; client调用DistributionRequest函数向master请求cache server分布，其内部首先与master建立连接，如果连接失败则向备用master建立连接，之后发送请求分布的json数据，然后读取master返回的json数据，提取出cache server列表，并根据新的列表构造哈希环。 写入cache数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void Client::keyValueWrite()&#123; signal(SIGPIPE,SIG_IGN); ofstream outfile; outfile.open(KEY_FILE_NAME,ios::app); if(!outfile.is_open()) perr_exit(&quot;open file failed&quot;); json js=Writejs(KEY_VALUE_RESPOND); string key=js[&quot;data&quot;][&quot;key&quot;].get&lt;string&gt;(); string value=js[&quot;data&quot;][&quot;value&quot;].get&lt;string&gt;(); CountTime(); ipport_pair oneipbf=get_ipport(hash.GetServerIndex(key)); int n=ConnectServ(oneipbf,kvwritecfd); while(n&lt;0) &#123; Close(kvwritecfd); sleep(1); DistributionRequest(); oneipbf=get_ipport(hash.GetServerIndex(key)); n=ConnectServ(oneipbf,kvwritecfd); &#125; int nwrite=WriteData(kvwritecfd,js); if(nwrite&lt;0) oneipbf.port=0; outfile&lt;&lt;key&lt;&lt;&#x27; &#x27;&lt;&lt;value&lt;&lt;&#x27; &#x27;&lt;&lt;oneipbf.port&lt;&lt;endl; while(1) &#123; js=Writejs(KEY_VALUE_RESPOND); key=js[&quot;data&quot;][&quot;key&quot;].get&lt;string&gt;(); value=js[&quot;data&quot;][&quot;value&quot;].get&lt;string&gt;(); CountTime(); ipport_pair oneip=get_ipport(hash.GetServerIndex(key)); if(oneip.ip!=oneipbf.ip||oneip.port!=oneipbf.port) &#123; Close(kvwritecfd); n=ConnectServ(oneip,kvwritecfd); while(n&lt;0) &#123; Close(kvwritecfd); sleep(1); DistributionRequest(); oneip=get_ipport(hash.GetServerIndex(key)); n=ConnectServ(oneip,kvwritecfd); &#125; &#125; nwrite=WriteData(kvwritecfd,js); if(nwrite&lt;0) &#123; oneipbf.port=0; sleep(1); continue; &#125; oneipbf=oneip; outfile&lt;&lt;key&lt;&lt;&#x27; &#x27;&lt;&lt;value&lt;&lt;&#x27; &#x27;&lt;&lt;oneip.port&lt;&lt;endl; Sleep_ms(300); &#125; Close(kvwritecfd); outfile.close();&#125; client调用keyValueWrite函数向cache server定时循环写入随机键值对数据，并将其保存在本地文件中，供读取函数使用，以测试缓存命中率。写数据函数内部首先根据key找到其对应的cache服务器，然后向其建立连接，如果连接失败则循环向master请求cache分布，再与key对应的服务器建立连接，知道连接成功建立。之后循环进行以上过程，其中还需要调用CountTime函数定时，每经过5秒便重新向master请求cache分布，避免本地缓存失效。 读取cache数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051string Client::keyValueRequest(const string key)&#123; json js=Writejs(key); json jsin; ipport_pair oneip; int j=0; while(1) &#123; CountTime(); oneip=get_ipport(hash.GetServerIndex(key)); int n=ConnectServ(oneip,kvreqcfd); while(n&lt;0) &#123; Close(kvreqcfd); sleep(1); DistributionRequest(); oneip=get_ipport(hash.GetServerIndex(key)); n=ConnectServ(oneip,kvreqcfd); &#125; int nwrite=WriteData(kvreqcfd,js); if(nwrite&lt;0) &#123; Close(kvreqcfd); DistributionRequest(); continue; &#125; jsin=ReadData(kvreqcfd); if(jsin.empty()) &#123; Close(kvreqcfd); perr_exit(&quot;connection with cache fails&quot;); &#125; else if(jsin[&quot;data&quot;][&quot;flag&quot;]==false) &#123; Close(kvreqcfd); DistributionRequest(); j++; if(j&gt;2) perr_exit(&quot;Data lose&quot;); continue; &#125; else if(jsin[&quot;type&quot;]==KEY_VALUE_REQUEST&amp;&amp;jsin[&quot;data&quot;][&quot;key&quot;]==key) break; else perr_exit(&quot;key value request returns fault&quot;); &#125; Close(kvreqcfd); string value=jsin[&quot;data&quot;][&quot;value&quot;].get&lt;string&gt;(); return value;&#125; client调用keyValueRequest函数向cache读取指定key的value。函数内部首先通过Writejs函数打开保存了键值对的本地文件，之后提取出key，与其对应的cache服务器建立连接，如果建立失败则向master拉取cache分布，循环知道成功建立连接，随后发送请求key数据包，然后读取cache返回的json数据，提出其中的value数据。","categories":[{"name":"分布式缓存","slug":"分布式缓存","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"client","slug":"client","permalink":"http://example.com/tags/client/"}]},{"title":"cache模块——心跳包","slug":"cache模块—心跳包","date":"2022-05-12T10:01:21.000Z","updated":"2022-05-29T06:22:54.886Z","comments":true,"path":"2022/05/12/cache模块—心跳包/","link":"","permalink":"http://example.com/2022/05/12/cache%E6%A8%A1%E5%9D%97%E2%80%94%E5%BF%83%E8%B7%B3%E5%8C%85/","excerpt":"整体概述cache server在运行时，新建一个线程定时向master发送心跳包，以确保master能确定自己的存活状态，同时接收master发送的指令，根据指令不同进行对应的操作。","text":"整体概述cache server在运行时，新建一个线程定时向master发送心跳包，以确保master能确定自己的存活状态，同时接收master发送的指令，根据指令不同进行对应的操作。 基础知识缓存扩缩容分布式缓存中存在多个cache server节点，当节点增加或者减少时，数据对应的存储节点也需要发送变化。master监控着所有cache server节点发送来的心跳包，因此可以检测到节点变化，此时向其它节点发送指令，进行对应的操作。 ADD_CACHE_SERVER：扩容命令，说明有新的cache server节点加入，此时将json数据包中的IP列表读出，新建一个线程，通过一致性哈希算法将LRU对象中的所有数据与其对应的缓存节点对应起来，并新建线程向cache server服务器发送对应的所有数据。 SHUTDOWN_CACHE_SERVER：缩容命令，也就是本cache server服务器需要主动关闭，此时同样将json数据包中的IP列表读出，新建一个线程，通过一致性哈希算法将LRU对象中的所有数据与其对应的缓存节点对应起来，并新建线程向cache server服务器发送对应的所有数据，发送完毕后退出整个程序。 REFLESH_IP：备份命令，说明此时有其它cache server服务器关闭了，将备份LRU对象中的数据读出，并通过一致性哈希算法与服务器对应起来，如果该数据属于本服务器，则从备份LRU对象中写到LRU对象中，最后分别建立线程向其它cache server服务器发送其对应的所有数据。 核心代码分析cache发送数据123456789101112131415161718192021222324252627282930313233343536373839void *task_connectoth(void *arg)&#123; pthread_mutex_lock(&amp;transfertooth); struct task_connect_oth* taskconnect((struct task_connect_oth*) arg); pthread_mutex_unlock(&amp;transfertooth); auto ipport_s = get_ipport(taskconnect-&gt;addr); string&amp; ip_oth = ipport_s.ip; int&amp; port_oth = ipport_s.port; int cachfd = Socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in cache_oth_addr; bzero(&amp;cache_oth_addr,sizeof(cache_oth_addr)); cache_oth_addr.sin_family = AF_INET; inet_pton(AF_INET, (const char*)ip_oth.data(), &amp;cache_oth_addr.sin_addr.s_addr); cache_oth_addr.sin_port = htons(port_oth); int ret = connect(cachfd, (struct sockaddr *)&amp;cache_oth_addr, sizeof(cache_oth_addr)); auto flags = fcntl(cachfd,F_GETFL,0); fcntl(cachfd, F_SETFL, flags &amp; O_NONBLOCK); if(ret&lt;0) return nullptr; for(int j=0; j&lt;(*taskconnect-&gt;ipport_and_key)[taskconnect-&gt;addr].size(); j++) &#123; string key = (*taskconnect-&gt;ipport_and_key)[taskconnect-&gt;addr][j]; string value = (*taskconnect-&gt;LC).get(key, false); json write_j = Write_oth_ClientCache(key, value); string buf = write_j.dump()+&quot;\\0&quot;; int n=Write(cachfd, (const char *)buf.data(), buf.length()+1); if(n==0) &#123; Close(cachfd); return nullptr; &#125; Sleep_ms(100); &#125; Close(cachfd); return nullptr;&#125; task_connectoth函数用于cache server与其它cache server建立连接，发送数据。 cache节点变化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void* doit_iplistchange(void *arg)&#123; pthread_rwlock_wrlock(&amp;shutdown_lock); struct iplistchange_struct* ipchange=(struct iplistchange_struct *)arg; shared_ptr&lt;unordered_map&lt;string,vector&lt;string&gt;&gt;&gt; ipport_and_key=make_shared&lt;unordered_map&lt;string,vector&lt;string&gt;&gt;&gt;(); (*ipchange-&gt;key_addr).RefreshIPList(*ipchange-&gt;ipport_list); if(ipchange-&gt;exit_flag) cout&lt;&lt;&quot;prepare to close...&quot;&lt;&lt;endl; for(auto i = (*ipchange-&gt;LC).cache.begin(); i!=(*ipchange-&gt;LC).cache.end();i++)&#123; string key = i-&gt;first; string addr = (*ipchange-&gt;key_addr).GetServerIndex(key); (*ipport_and_key)[addr].push_back(key); &#125; signal(SIGPIPE, SIG_IGN); struct task_connect_oth task_arg; task_arg.ipport_and_key = ipport_and_key; task_arg.LC = ipchange-&gt;LC; pthread_t takeout_allval[ipport_and_key-&gt;size()]; int count = 0; int flag = -1; for(auto i = ipport_and_key-&gt;begin(); i!=ipport_and_key-&gt;end(); i++) &#123; Sleep_ms(100); if(curen_addr==i-&gt;first) &#123; flag = count++; continue; &#125; pthread_mutex_lock(&amp;transfertooth); task_arg.addr = i-&gt;first; Pthread_create(&amp;takeout_allval[count++], nullptr, &amp;task_connectoth, &amp;task_arg); pthread_mutex_unlock(&amp;transfertooth); &#125; Sleep_ms(200); for(int i=0; i&lt;ipport_and_key-&gt;size(); i++)&#123; if(flag==i) continue; pthread_join(takeout_allval[i], nullptr); &#125; if(ipchange-&gt;exit_flag) &#123; cout&lt;&lt;&quot;close done&quot;&lt;&lt;endl; exit(0); &#125; pthread_rwlock_unlock(&amp;shutdown_lock); return nullptr;&#125; doit_iplistchange函数内部根据一致性哈希算法对新的IP列表建立哈希环，然后将LRU中的数据与服务器对应起来，之后遍历所有数据，如果与本服务器对应则不做操作，如果对应于其它服务器，则调用task_connectoth函数发送数据，最后根据exit_flag标志，如果为真则直接退出程序，关闭服务器。 cache容灾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void Heartbeat::reflesh_handler()&#123; pthread_mutex_lock(&amp;ipchange_lock); (*ipport_list).clear(); unordered_set&lt;string&gt; ipnew; vector&lt;string&gt; key_send; sendout_bk-&gt;clear(); for(int i=0; i&lt;iplist_json[&quot;data&quot;][&quot;iplist&quot;].size(); i++)&#123; (*ipport_list).push_back(iplist_json[&quot;data&quot;][&quot;iplist&quot;][i]); ipnew.insert((string)iplist_json[&quot;data&quot;][&quot;iplist&quot;][i]); &#125; for(auto i = (*LC_BK).cache.begin(); i!=(*LC_BK).cache.end();i++)&#123; string key = i-&gt;first; string addr = (*key_addr).GetServerIndex(key); if(ipnew.find(addr)==ipnew.end())&#123; key_send.push_back(key); &#125; &#125; (*key_addr).RefreshIPList(*ipport_list); for(int i=0; i&lt;key_send.size(); i++)&#123; (*sendout_bk)[(*key_addr).GetServerIndex(key_send[i])].push_back(key_send[i]); &#125; if(!(sendout_bk-&gt;empty()))&#123; signal(SIGPIPE, SIG_IGN); int count=0; task_arg.LC = LC_BK; task_arg.ipport_and_key = sendout_bk; int flag=-1; for(auto i = sendout_bk-&gt;begin(); i!=sendout_bk-&gt;end(); i++)&#123; if(curen_addr==i-&gt;first)&#123; for(int j=0; j&lt;(*sendout_bk)[curen_addr].size(); j++)&#123; string temp_key = (*sendout_bk)[curen_addr][j]; string temp_val = LC_BK-&gt;get(temp_key, false); LC-&gt;put(temp_key, temp_val); &#125; flag = count++; continue; &#125; Sleep_ms(100); pthread_mutex_lock(&amp;transfertooth); task_arg.addr = i-&gt;first; Pthread_create(&amp;takeout_allval[count++], nullptr, &amp;task_connectoth, &amp;task_arg); pthread_mutex_unlock(&amp;transfertooth); &#125; &#125; pthread_mutex_unlock(&amp;ipchange_lock);&#125; 当系统中有一个cache server服务器关闭时，其它cache server便调用此函数，首先对比json数据包和自身的IP列表，判断在备份LRU中有哪些key需要转移节点，然后判断需要转移的key对应的服务器是否是自身，如果是则从备份LRU中移动到LRU，如果不是则调用task_connectoth函数发送至目标服务器。 cache发送心跳包123456789101112131415161718192021222324void *heart_beat(void *arg)&#123; Heartbeat heartbeat_hd((struct heartbeat_struct *)arg); heartbeat_hd.heartbeat_connect(false); while(1)&#123; heartbeat_hd.heartbeat_send(); Sleep_ms(100); int commond = heartbeat_hd.is_anycommond(); if(SHUTDOWN_CACHE==commond)&#123; heartbeat_hd.shutdown_handler(); break; &#125; else if(ADD_CACHE==commond)&#123; heartbeat_hd.add_handler(); &#125; else if(REFLESH_IP==commond)&#123; heartbeat_hd.reflesh_handler(); &#125; &#125; while(1)&#123; sleep(100); &#125; return nullptr;&#125; cache server服务器在main主函数中创建一个新线程运行heart_beat函数，内部首先调用heartbeat_connect函数与master建立连接，然后定时循环调用heartbeat_send函数向master发送心跳包，使用is_anycommond函数接收master指令，如果json数据包指令为SHUTDOWN_CACHE，说明需要关闭本cache server，此时调用shutdown_handler函数，其内部调用doit_iplistchange函数转移数据；如果指令为ADD_CACHE，说明有新的cache server加入，此时调用add_handler函数，其内部调用doit_iplistchange函数转移数据；如果指令为REFLESH_IP，说明有其它cache server关闭，此时调用reflesh_handle函数，转移备份LRU中属于被关闭cache server的数据。","categories":[{"name":"分布式缓存","slug":"分布式缓存","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"cache","slug":"cache","permalink":"http://example.com/tags/cache/"},{"name":"心跳包","slug":"心跳包","permalink":"http://example.com/tags/%E5%BF%83%E8%B7%B3%E5%8C%85/"}]},{"title":"cache模块——数据读写","slug":"cache模块—数据读写","date":"2022-05-10T10:01:21.000Z","updated":"2022-05-29T06:22:53.172Z","comments":true,"path":"2022/05/10/cache模块—数据读写/","link":"","permalink":"http://example.com/2022/05/10/cache%E6%A8%A1%E5%9D%97%E2%80%94%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/","excerpt":"整体概述cache server是一个可以同时向多个client提供服务的服务器，其并发能力至关重要，所以采用epoll和线程池架构来提高cache server服务器的并发处理能力，即通过epoll函数监听多个事件，并让对应的处理函数交于线程池中的工作线程处理。同时还需要处理master容灾时备份master发送过来的IP和端口号信息。","text":"整体概述cache server是一个可以同时向多个client提供服务的服务器，其并发能力至关重要，所以采用epoll和线程池架构来提高cache server服务器的并发处理能力，即通过epoll函数监听多个事件，并让对应的处理函数交于线程池中的工作线程处理。同时还需要处理master容灾时备份master发送过来的IP和端口号信息。 基础知识epoll函数epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select&#x2F;poll的增强版本，在获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。 客户端请求cache接收到的请求可能是client的，也可能是其它cache server的，还可能是master的，根据json数据包的type可以判断并且做出相应逻辑处理。 KEY_VALUE_REQUEST：client发起的读数据请求，从LRU中读取出key对应的value，再发送给client。 KEY_VALUE_RESPOND：client发起的写数据请求，则将数据写入到LRU中。同时通过一致性哈希算法找到该数据对应的备份cache服务器，将该数据的type改成KEY_VALUE_REPONDBK，然后将其发送到该备份服务器。 KEY_VALUE_RESPONDBK：其它cache server服务器发送的写数据请求，则将数据写入到备份LRU中。 REFLESH_MASTER：备份master发起的命令，更改master的IP地址和端口号。 核心代码分析建立master连接123456789101112131415161718void WriteRead::WR_listen()&#123; listenfd = Socket(AF_INET, SOCK_STREAM, 0); int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = inet_addr(CACHESERV_IP); servaddr.sin_port = htons(CACHESERV_PORT);//test!!!!!!!!!!!!! Bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); Listen(listenfd, listen_num); efd = Epoll_create(openmax); task_arg_listen.efd = efd; task_arg.efd = efd; tep.events = EPOLLIN | EPOLLET; tep.data.fd = listenfd; Epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);&#125; 通过socket、bind、listen建立socket连接，之后将套接字添加进epoll函数中监听。 处理新连接请求123456789101112131415161718192021222324252627282930313233void WriteRead::WR_listenHandler()&#123; pthread_mutex_lock(&amp;tasklisten_lock); task_arg_listen.cliaddr = &amp;cliaddr; task_arg_listen.listenfd = listenfd; task_arg_listen.num = ++num; Task TT(task_listen, &amp;task_arg_listen); (*ThrPl).addTask(TT); pthread_mutex_unlock(&amp;tasklisten_lock);&#125;void task_listen(void *task_arg)&#123; pthread_rwlock_rdlock(&amp;shutdown_lock); pthread_mutex_lock(&amp;tasklisten_lock); struct pack_tasklisten* task_lst((struct pack_tasklisten *)task_arg); pthread_mutex_unlock(&amp;tasklisten_lock); socklen_t clilen = sizeof(task_lst-&gt;cliaddr); int connfd = Accept(task_lst-&gt;listenfd, (struct sockaddr *)&amp;task_lst-&gt;cliaddr, &amp;clilen); struct sockaddr_in cliaddr; char str[INET_ADDRSTRLEN]; cout&lt;&lt;&quot;received from &quot;&lt;&lt;inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str))&lt;&lt;&quot; at PORT &quot;&lt;&lt;ntohs(cliaddr.sin_port)&lt;&lt;endl; auto flag = fcntl(connfd, F_GETFL); fcntl(connfd, F_SETFL, flag | O_NONBLOCK); struct epoll_event tep; tep.events = EPOLLIN | EPOLLOUT | EPOLLET; tep.data.fd = connfd; Epoll_ctl(task_lst-&gt;efd, EPOLL_CTL_ADD, connfd, &amp;tep); pthread_rwlock_unlock(&amp;shutdown_lock);&#125; 当epoll函数返回的事件是监听套接字时，代表此时有新连接接入，此时调用WR_listenHandler函数处理新连接，其内部将task_listen函数添加进工作队列，使用线程池中的工作线程处理。task_listen函数接收新连接，并将其添加进epoll函数监听。 处理已连接事件IO12345678910111213141516171819202122232425262728293031323334void WriteRead::WR_cfdHandler(int index)&#123; pthread_mutex_lock(&amp;task_lock); task_arg.buf = buf; task_arg.sockfd = ep[index].data.fd; Task TT(task_cfd, &amp;task_arg); (*ThrPl).addTask(TT); pthread_mutex_unlock(&amp;task_lock);&#125;void task_cfd(void *arg)&#123; pthread_rwlock_rdlock(&amp;shutdown_lock); pthread_mutex_lock(&amp;task_lock); Task_putget task_pg((struct pack_taskconnect *)arg); pthread_mutex_unlock(&amp;task_lock); ssize_t n = task_pg.read_fromclient(); if(n==0) task_pg.closeconnect(); else if(n&gt;0) &#123; const int infotype = task_pg.is_infotype(); if(infotype==KEY_VALUE_REQUEST) task_pg.kvrequest_handler(); else if(infotype==KEY_VALUE_RESPOND||infotype==KEY_VALUE_RESPONDBK) task_pg.kvrespond_handler(); else if(infotype==REFLESH_MASTER) &#123; pthread_mutex_lock(&amp;reflesh_master_lock); master_addr = task_pg.refleshmaster(); pthread_mutex_unlock(&amp;reflesh_master_lock); &#125; &#125; pthread_rwlock_unlock(&amp;shutdown_lock);&#125; 当epoll函数返回的是已建立连接的套接字时，代表有IO请求发生，此时将task_cfd函数添加进线程池的工作队列中。task_cfd内部首先调用read_fromclient函数读取套接字中的json数据包，如果数据为空，则使用closeconnect函数关闭套接字；如果json数据包类型为KEY_VALUE_RESQUEST，则调用kvrequest_handler函数处理client的读数据请求；当类型为KEY_VALUE_RESPOND或KEY_VALUE_RESPONDBK时，调用kvrespond_handler函数处理client或cache server的写数据请求；如果类型为REFLESH_MASTER，则更新master的IP地址和端口号。 cache读数据123456789101112void Task_putget::kvrequest_handler()&#123; pthread_rwlock_rdlock(&amp;rw_lock); info[&quot;data&quot;][&quot;value&quot;] = (*LC).get(info[&quot;data&quot;][&quot;key&quot;]); if(info[&quot;data&quot;][&quot;value&quot;]==&quot;&quot;) info[&quot;data&quot;][&quot;flag&quot;] = false; else info[&quot;data&quot;][&quot;flag&quot;] = true; string str_out = info.dump()+&quot;\\0&quot;; Write(sockfd, (char *)str_out.data(), str_out.length()+1); pthread_rwlock_unlock(&amp;rw_lock);&#125; cache处理读数据请求的函数，当读取成功时，将flag标志置1，否则置0。 cache写数据12345678910111213141516171819202122232425262728293031323334353637void Task_putget::kvrespond_handler()&#123; pthread_rwlock_wrlock(&amp;rw_lock); if(info[&quot;type&quot;]==KEY_VALUE_RESPONDBK) &#123; cout&lt;&lt;&quot;the number of receiving backup data is &quot;&lt;&lt;++rcv_bk&lt;&lt;endl; (*LC_BK).put(info[&quot;data&quot;][&quot;key&quot;], info[&quot;data&quot;][&quot;value&quot;]); pthread_rwlock_unlock(&amp;rw_lock); return; &#125; cout&lt;&lt;&quot;the number of receiving stored data is &quot;&lt;&lt;++rcv_cli&lt;&lt;endl; (*LC).put(info[&quot;data&quot;][&quot;key&quot;], info[&quot;data&quot;][&quot;value&quot;]); string addr = key_addr-&gt;GetBackUpServer(info[&quot;data&quot;][&quot;key&quot;]); if(!addr.empty() &amp;&amp; addr!=curen_addr) &#123; auto ipport_s = get_ipport(addr); string&amp; ip = ipport_s.ip; int&amp; port = ipport_s.port; int cachfd = Socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in cache_bk_addr; bzero(&amp;cache_bk_addr,sizeof(cache_bk_addr)); cache_bk_addr.sin_family = AF_INET; inet_pton(AF_INET, (const char*)ip.data(), &amp;cache_bk_addr.sin_addr.s_addr); cache_bk_addr.sin_port = htons(port); if(!(connect(cachfd, (struct sockaddr *)&amp;cache_bk_addr, sizeof(cache_bk_addr))&lt;0)) &#123; auto flags = fcntl(cachfd,F_GETFL,0); fcntl(cachfd,F_SETFL,flags|O_NONBLOCK); json sout_data = Write_bk_ClientCache((const string)info[&quot;data&quot;][&quot;key&quot;], (const string)info[&quot;data&quot;][&quot;value&quot;]); string s_data = sout_data.dump()+&quot;\\0&quot;; Write(cachfd, (char *)s_data.data(), s_data.length()+1); &#125; Close(cachfd); &#125; pthread_rwlock_unlock(&amp;rw_lock);&#125; cache处理写函数请求的函数。如果类型为KEY_VALUE_RESPONDBK，则将数据写入备份LRU中；如果类型为KEY_VALUE_RESPOND，则将数据写入LRU中，同时找到该key对应的备份cache server服务器，向其发送类型为KEY_VALUE_RESPONDBK的json数据包。","categories":[{"name":"分布式缓存","slug":"分布式缓存","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"cache","slug":"cache","permalink":"http://example.com/tags/cache/"},{"name":"数据读写","slug":"数据读写","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/"}]},{"title":"一致性哈希","slug":"一致性哈希","date":"2022-05-06T10:01:21.000Z","updated":"2022-05-29T06:22:49.633Z","comments":true,"path":"2022/05/06/一致性哈希/","link":"","permalink":"http://example.com/2022/05/06/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/","excerpt":"整体概述对于一个分布式key-value型缓存系统，某个key应该到哪个或者哪些节点上获得，应该是确定的。哈希算法可以保证对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个key确定到一个节点上，但是如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据。然而哈希算法在面对节点数量变化时，最坏情况下所有数据都需要迁移，成本高。因此需要采用一致性哈希算法，与哈希算法的不同之处在于，哈希算法是对节点的数量进行取模计算，而一致性哈希算法是对2^32进行取模运算。","text":"整体概述对于一个分布式key-value型缓存系统，某个key应该到哪个或者哪些节点上获得，应该是确定的。哈希算法可以保证对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个key确定到一个节点上，但是如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据。然而哈希算法在面对节点数量变化时，最坏情况下所有数据都需要迁移，成本高。因此需要采用一致性哈希算法，与哈希算法的不同之处在于，哈希算法是对节点的数量进行取模计算，而一致性哈希算法是对2^32进行取模运算。 基础知识一致性哈希理论 把对2^32进行取模运算的结果值组织成一个圆环，可以把这个圆想象成由2^32个点组成的圆（下图a）。 对存储节点进行哈希计算，例如根据节点的IP地址进行哈希（下图b）；当对数据进行存储或访问时，对数据进行哈希映射，根据映射的结果值往顺时针的方向找到第一个节点，就是存储该数据的节点（下图c）。 当增加（下图d）或者移除（下图e）一个节点时，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据不会受到影响。 虚拟结点一致性哈希算法并不保证节点能够在哈希环上分布均匀，这样就会带来一个问题，会有大量的请求集中在一个节点上（下图左），在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。因此要想解除节点在哈希环上分配不均匀的问题，就是要有大量的节点，当实际上我们没有那么多节点，所以需要加入虚拟节点，也就是对一个真实节点做多个副本。具体做法是，不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上（下图右），并将虚拟节点映射到实际节点。 核心代码分析GETHash函数1234567891011121314151617uint32_t ConsistentHash::GETHash(string key)&#123; const int p=16777619; uint32_t hash=2166136261; for(int index=0;index&lt;key.size();index++) &#123; hash=(hash^key[index])*p; &#125; hash+=hash&lt;&lt;13; hash^=hash&gt;&gt;7; hash+=hash&lt;&lt;3; hash^=hash&gt;&gt;17; hash+=hash&lt;&lt;5; if(hash&lt;0) hash=-hash; return hash;&#125; 采用的32位Fowler-Noll-Vo算法,将Cache Server的地址端口以及key映射到环上的哈希算法。该算法能快速哈希大量数据并保持较小的冲突率，具有高度分散性，使得它适用于处理一些非常相近的字符串。 构造哈希环123456789101112131415161718192021222324bool ConsistentHash::RefreshIPList(const vector&lt;string&gt;&amp; iplist)&#123; virtualNodes.clear(); serverNodes.clear(); bool f=true; for(auto&amp; ip:iplist) &#123; f=f&amp;&amp;AddServer(ip); &#125; return f;&#125;bool ConsistentHash::AddServer(const string&amp; nodeIP)&#123; for(int i=0;i&lt;virtualNodeNum;i++) &#123; stringstream nodeKey; nodeKey&lt;&lt;nodeIP&lt;&lt;&quot;#&quot;&lt;&lt;i; uint32_t partition=GETHash(nodeKey.str()); virtualNodes.insert(&#123;partition,nodeIP&#125;); &#125; uint32_t partition=GETHash(nodeIP); serverNodes.insert(&#123;partition,nodeIP&#125;); return true;&#125; 根据IP列表构建哈希环，其中virtulNodeNum为设置的虚拟节点数量。 获得key对应的节点和备份节点12345678910111213141516171819202122232425262728string ConsistentHash::GetServerIndex(const string&amp; key)&#123; uint32_t partition=GETHash(key); auto it=virtualNodes.lower_bound(partition); if(it==virtualNodes.end()) &#123; if(virtualNodes.empty()) cout&lt;&lt;&quot;no available nodes&quot;&lt;&lt;&#x27;\\n&#x27;; return virtualNodes.begin()-&gt;second; &#125; return it-&gt;second;&#125;string ConsistentHash::GetBackUpServer(const string&amp; key)&#123; uint32_t partition=GETHash(key); auto it=virtualNodes.lower_bound(partition); if(it==virtualNodes.end()) it=virtualNodes.begin(); while(it!=virtualNodes.end()) &#123; it++; if(it==virtualNodes.end()) it=virtualNodes.begin(); if(it-&gt;second!=GetServerIndex(key)) break; &#125; return it-&gt;second;&#125; 通过key的哈希值，找到哈希环上顺时针方向上的第一个cache server节点，此为该key对应的存储节点，同时找到备份节点。","categories":[{"name":"分布式缓存","slug":"分布式缓存","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"一致性哈希","slug":"一致性哈希","permalink":"http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"}]},{"title":"通信格式及辅助函数","slug":"通信格式及辅助函数","date":"2022-05-05T04:01:21.000Z","updated":"2022-05-29T06:22:46.165Z","comments":true,"path":"2022/05/05/通信格式及辅助函数/","link":"","permalink":"http://example.com/2022/05/05/%E9%80%9A%E4%BF%A1%E6%A0%BC%E5%BC%8F%E5%8F%8A%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/","excerpt":"整体概述采用JSON格式作为master、cache server和client之间的通行数据格式，借助德国大牛nlohmann写的json for modern C++，只需要包含头文件json.hpp，再using json &#x3D; nlohmann::json;就可以直接使用。同时封装了需要在项目中多次使用的函数。","text":"整体概述采用JSON格式作为master、cache server和client之间的通行数据格式，借助德国大牛nlohmann写的json for modern C++，只需要包含头文件json.hpp，再using json &#x3D; nlohmann::json;就可以直接使用。同时封装了需要在项目中多次使用的函数。 基础知识json格式123456789101112json data=&#123; &quot;type&quot;:XXX, &quot;data&quot;: &#123; &quot;XXX&quot;:XXX, &quot;XXX&quot;:[XXX,XXX] &#125;&#125;json::parse() //json数据包转换为字符串json::dump() //字符串转换为json格式json::accept() //判断是否为json格式 项目中采用的json数据报格式如上所示，并设计了json格式。 表头 表头 KEY_VALUE_REQUEST Client向Cache Server请求数据 KEY_VALUE_RESPOND Cache Server向Client发送数据 HEART_BEAT Cache Server向Master发送心跳包 DISTRIBUTION_REQUEST Client向Master拉取节点分布 DISTRIBUTION_RESPOND Master向Client发送节点分布 SHUTDOWN_CACHE SERVER Master向Cache Server发送关闭节点指令 ADD_CACHE SERVER 主动扩容，Master向Client发送节点分布 SPARE_MASTER 主Master向从Master发送心跳包 REFLESH_MASTER 主Master关闭，从Master发布重连信息 REFLESH_IP 主动&#x2F;被动缩容时，Master向Client发送节点分布 KEY_VALUE_RESPONDBK Cache Server内部数据转移 DISTRIBUTION_REQUESTBK Cache Server收到了Client的数据请求 Socket相关函数Socket是在应用层和传输层之间的一个抽象层，它把TCP&#x2F;IP层复杂的操作抽象为几个简单的接口，供应用层调用实现进程在网络中的通信。项目中对Socket通信中常用的函数进行了封装。 1234567891011121314//建立socket套接字int Socket(int family,int type,int protocol);//绑定socket套接字int Bind(int fd,const struct sockaddr* sa,socklen_t len);//监听socket套接字int Listen(int fd,int backlog);//建立连接int Connect(int fd,const struct sockaddr* sa,socklen_t len);//向服务端发起连接int Socket_connect(bool first_call,const struct sockaddr* sa,socklen_t len);//接收连接int Accept(int fd,struct sockaddr* sa,socklen_t* len);//关闭文件描述符int Close(int fd); 文件读写函数1234ssize_t Read(int fd,char* ptr,size_t nbyte);ssize_t Readonce(int cfd,char* buf,int size);ssize_t unblock_read_net(int cfd,char* buf,int size);ssize_t Write(int fd,const void* ptr,size_t nbyte); Epoll相关函数epoll 全称 eventpoll，是 linux 内核实现IO多路复用（IO multiplexing）的一个实现。IO多路复用的意思是在一个操作里同时监听多个输入输出源，在其中一个或多个输入输出源可用的时候返回，然后对其的进行读写操作。 123456//创建epoll文件int Epoll_create(int size);//向epoll中添加/删除/修改需要监听的文件描述符int Epoll_ctl(int epfd,int op,int fd,struct epoll_event* event);//监听epoll中的文件描述符int Epoll_wait(int epfd,struct epoll_event* events,int maxevents,int timeout); 其它函数cache的地址定义为string字符串：IP+端口号，get_ipport函数用于从地址字符串中取出IP和端口号，放入ipport_pair结构体中。 12345678910111213struct ipport_pair&#123; int port; string ip;&#125;;ipport_pair get_ipport(string addr)&#123; struct ipport_pair res; int cut=addr.find_last_of(&#x27;:&#x27;); res.ip=addr.substr(0,cut); res.port=stoi(addr.substr(cut+1)); return res;&#125; 获得指定长度的随机字符串，用于生成随机key和value。 1234567891011121314151617181920212223242526string RandStr(const int len)&#123; struct timeval timeSeed; gettimeofday(&amp;timeSeed,NULL); srand(1000000*timeSeed.tv_sec+timeSeed.tv_usec); string ans; int i; for(i=0;i&lt;len;i++) &#123; char c; switch ((rand()%3)) &#123; case 1: c=RAND(&#x27;A&#x27;,&#x27;Z&#x27;); break; case 2: c=RAND(&#x27;a&#x27;,&#x27;z&#x27;); break; default: c=RAND(&#x27;0&#x27;,&#x27;9&#x27;); &#125; ans+=c; &#125; ans[++i]=&#x27;\\0&#x27;; return ans;&#125;","categories":[{"name":"分布式缓存","slug":"分布式缓存","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"通信格式","slug":"通信格式","permalink":"http://example.com/tags/%E9%80%9A%E4%BF%A1%E6%A0%BC%E5%BC%8F/"},{"name":"辅助函数","slug":"辅助函数","permalink":"http://example.com/tags/%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"}]},{"title":"缓存淘汰-LRU","slug":"缓存淘汰策略-LRU","date":"2022-05-03T05:01:21.000Z","updated":"2022-05-29T06:22:39.878Z","comments":true,"path":"2022/05/03/缓存淘汰策略-LRU/","link":"","permalink":"http://example.com/2022/05/03/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5-LRU/","excerpt":"整体概述缓存一般从以下三个特征进行描述：命中率、最大空间、淘汰策略。缓存的存储空间有限制，当缓存空间被用满时，有淘汰策略来保证可靠的命中率。本项目采用LRU（least recently used）策略，它是目前最常用的缓存算法和设计方案之一，其移除策略为“当缓存（页）满时，优先移除最近最久未使用的数据”，优点是易于设计和使用，适用场景广泛。","text":"整体概述缓存一般从以下三个特征进行描述：命中率、最大空间、淘汰策略。缓存的存储空间有限制，当缓存空间被用满时，有淘汰策略来保证可靠的命中率。本项目采用LRU（least recently used）策略，它是目前最常用的缓存算法和设计方案之一，其移除策略为“当缓存（页）满时，优先移除最近最久未使用的数据”，优点是易于设计和使用，适用场景广泛。 基础知识LRU算法LRU算法认为，最近被频繁访问的数据会具备更高的留存，淘汰那些不常被访问的数据。根据LRU算法的理念，我们需要：一个参数cap来作为最大容量，一种数据结构来存储数据，并且需要1. 轻易地更新最新的访问的数据。2. 轻易地找出最近最少被使用的数据，当到达cap时，清理掉。在项目中，我们用到的数据结构是：hashmap+双向链表。 利用hashmap的get、put方法O(1)的时间复杂度，快速取、存数据 利用双向链表的特征（可以访问到某个节点之前和之后的节点），实现O(1)的新增和删除数据。 核心代码分析成员变量123456789101112131415//带前后指针的节点struct DLinkedNode&#123; string key,value; DLinkedNode* prev; DLinkedNode* next; DLinkedNode():key(20,&#x27; &#x27;),value(20,&#x27; &#x27;),prev(nullptr),next(nullptr)&#123;&#125; DLinkedNode(string _key,string _value):key(_key),value(_value),prev(nullptr),next(nullptr)&#123;&#125;&#125;;//LRU类的成员变量 unordered_map&lt;string,DLinkedNode*&gt; cache; vector&lt;string&gt; key_vec; DLinkedNode* head; DLinkedNode* tail; int size; LRU类初始化1234567LRUCache::LRUCache(int _capacity):capacity(_capacity),size(0)&#123; head=new DLinkedNode(); tail=new DLinkedNode(); head-&gt;next=tail; tail-&gt;prev=head;&#125; 头结点和尾结点相连。 移动节点1234567891011121314151617181920212223void LRUCache::addToHead(DLinkedNode* node)&#123; node-&gt;prev=head; node-&gt;next=head-&gt;next; head-&gt;next-&gt;prev=node; head-&gt;next=node;&#125;void LRUCache::removeNode(DLinkedNode* node)&#123; node-&gt;prev-&gt;next=node-&gt;next; node-&gt;next-&gt;prev=node-&gt;prev;&#125;void LRUCache::moveToHead(DLinkedNode* node)&#123; removeNode(node); addToHead(node);&#125;DLinkedNode* LRUCache::removeTail()&#123; DLinkedNode* node=tail-&gt;prev; removeNode(node); return node;&#125; addToHead函数用于将目标节点添加至双向链表的头部。removeNode函数用于删除目标节点。moveToHead函数内部调用前两个函数，将双向链表中最近读取的节点移动至头部。removeTail函数用于删除双向链表中的尾部节点，即当达到最大容量时，删除最近最久未使用的数据。 读取节点1234567891011121314151617181920212223242526272829303132string LRUCache::get(string key,bool flag=true)&#123; if(!cache.count(key)) return &quot;&quot;; DLinkedNode* node=cache[key]; if(flag) moveToHead(node); return node-&gt;value;&#125;void LRUCache::put(string key,string value)&#123; if(!cache.count(key)) &#123; DLinkedNode* node=new DLinkedNode(key,value); cache[key]=node; addToHead(node); size++; if(size&gt;capacity) &#123; DLinkedNode* removed=removeTail(); cache.erase(removed-&gt;key); delete removed; size--; &#125; &#125; else &#123; DLinkedNode* node=cache[key]; node-&gt;value=value; moveToHead(node); &#125;&#125; get函数用于从双向链表中读取key对应的value，其中设置了标志位flag，默认为true，此时将读取的key移动至双向链表的头部。put函数用于向双向链表中添加数据，当key存在时，刷新value并移动至头部，当不存在时，先判断是否达到最大容量，未到达时直接将节点添加至头部，如果已到达最大容量，则需要删除尾部节点。","categories":[{"name":"分布式缓存","slug":"分布式缓存","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"LRU","slug":"LRU","permalink":"http://example.com/tags/LRU/"}]},{"title":"WebServer类","slug":"WebServer类","date":"2022-03-24T01:24:34.000Z","updated":"2022-05-29T06:23:02.492Z","comments":true,"path":"2022/03/24/WebServer类/","link":"","permalink":"http://example.com/2022/03/24/WebServer%E7%B1%BB/","excerpt":"整体概述基于浏览器&#x2F;服务器（B&#x2F;S）模型，实现了Web服务器的基本功能，用户通过浏览器实现，一部分事务逻辑在浏览器实现，主要事务逻辑在服务端实现，主要可以分为三层架构： 表示层：web浏览器。位于客户端，其任务是通过web浏览器向网络上的某个web服务器提出服务请求 功能层：具有应用程序扩展功能的web服务器，负责事物逻辑处理，位于web服务器端，其任务是接受用户的请求，进行数据库连接 数据层：数据库服务器。负责数据处理逻辑，位于数据库服务器端，其任务是接受web服务器对数据库 的操纵请求，实现对数据库查询、修改、更新等功能","text":"整体概述基于浏览器&#x2F;服务器（B&#x2F;S）模型，实现了Web服务器的基本功能，用户通过浏览器实现，一部分事务逻辑在浏览器实现，主要事务逻辑在服务端实现，主要可以分为三层架构： 表示层：web浏览器。位于客户端，其任务是通过web浏览器向网络上的某个web服务器提出服务请求 功能层：具有应用程序扩展功能的web服务器，负责事物逻辑处理，位于web服务器端，其任务是接受用户的请求，进行数据库连接 数据层：数据库服务器。负责数据处理逻辑，位于数据库服务器端，其任务是接受web服务器对数据库 的操纵请求，实现对数据库查询、修改、更新等功能 基础知识Socket通信Socket（套接字）用来描述IP地址和端口，是通信链的句柄，应用程序可以通过Socket向网络发送请求或者应答网络请求。Socket是支持TCP&#x2F;IP协议的网络通信的基本操作单元，是对网络通信过程中端点的抽象表示，包含了进行网络通信所必须的五种信息：连接所使用的协议；本地主机的IP地址；本地远程的协议端口；远程主机的IP地址；远程地址的协议端口。在基于TCP协议的Socket通信过程中，服务端首先声明一个Socket对象并指定端口号，然后调用accept方法接受客户端的数据。accept方法在没有数据进行接受时处于堵塞状态；客户端创建Socket对象，执行服务器端的IP地址和端口号，与服务端建立通信。 字节序不同的CPU有不同的字节序类型 这些字节序是指整数在内存中保存的顺序 这个叫做主机字节序，最常见的有两种，小端：将低序字节存储在起始地址；大端：将高序字节存储在起始地址。网络字节顺序是TCP&#x2F;IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用大端方式。为了在主机字节序和网络字节序中进行转换，提供了四个转换函数： htons：把unsigned short类型从主机序转换到网络序； htonl：把unsigned long类型从主机序转换到网络序； ntohs：把unsigned short类型从网络序转换到主机序； ntohl：把unsigned long类型从网络序转换到主机序； 基础API创建socket1int socket(int domain, int type, int protocol); 作用：建立一个协议族为domain、协议类型为type、协议编号为protocol的套接字文件描述符； 参数： domain：设置网络通信的域； PF_UNIX,PF_LOCAL：本地通信； AF_INET,PF_INET：IPV4协议； PF_INET6：IPV6协议； type：设置套接字通信的类型； SOCK_STREAM：Tcp连接，提供序列化的、可靠的、双向连接的字节流。支持带外数据传输； SOCK_DGRAM：支持UDP连接（无连接状态的消息）； protocol：制定某个协议的特定类型，即type类型中的某个类型。通常某协议中只有一种特定类型，这样protocol参数仅能设置为0；但是有些协议有多种特定的类型，需要设置这个参数来选择特定的类型； 返回值：调用成功返回一个标识这个套接字的文件描述符，失败的时候返回-1； 设置socket1int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen); 作用：设置与某个套接字关联的选项； 参数： sock：需要设置的套接字； level：指定控制套接字的层次： SOL_SOCKET：通用套接字选项； IPPROTO_IP：IP选项； IPPROTO_TCP：TCP选项； optname：指定控制的方式： SO_LINGER：延迟关闭连接； optval：根据optname的数据类型进行转换； optlen：选项的长度； 返回值：成功返回0，失败返回-1； 绑定socket12345678int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); struct sockaddr_in &#123; short sin_family; // 2 字节 ，地址族，e.g. AF_INET, AF_INET6 unsigned short sin_port; // 2 字节 ，16位TCP/UDP 端口号 e.g. htons(3490)， struct in_addr sin_addr; // 4 字节 ，32位IP地址 char sin_zero[8]; // 8 字节 ，不使用&#125;; 作用：把一个地址族中的特定地址赋给socket； 参数： sockfd：通过socket()函数创建的socket套接字； addr：sockaddr结构体指针，指向要绑定给sockfd的协议地址； addrlen：地址的长度； 返回值：绑定成功返回0，失败返回-1； 监听socket1int listen(int sockfd,int backlog); 作用：使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程； 参数： sockfd：通过socket()函数创建的socket套接字； backlog：建立好连接处于ESTABLISHED状态的队列最大长度； 返回值：成功返回0，失败返回-1； 连接socket1int connect(int sockfd,struct sockaddr* serv_addr,int addrlen); 作用：客户端调用，与服务端建立TCP连接； 参数： sockfd：通过socket()函数创建的socket套接字； serv_addr：sockaddr结构体指针，保存了想要连接的服务端主机地址和端口号； addrlen：地址的长度； 返回值：成功返回0，失败返回-1； 接收socket1int accept(int socket,struct sockaddr* addr,socklen_t addrlen); 作用：服务端监听到客户端发送过来的connect请求后，调用accept函数接收请求，这样就建立好了连接； 参数： socket：通过socket()函数创建的socket套接字； addr：sockaddr结构体指针，保存了建立连接的客户端主机地址和端口号； addrlen：地址的长度； 返回值：成功返回0，失败返回-1； 创建管道通信1int socketpair(int domain, int type, int protocol, int sv[2]); 作用：创建管道进行进程间通信； 参数： domain：表示协议族，在Linux下只能为AF_LOCAL或者AF_UNIX； type：表示协议，可以是SOCK_STREAM（TCP）或者SOCK_DGRAM（UDP）； protocol：表示类型，只能为0； sv[2]：管道，两端都可以读写； 返回值：成功返回0，失败返回-1； 核心代码分析类成员变量12345678910111213141516171819202122connection_poll* m_connpool; //数据库连接池string m_user; //数据库信息:登录名string m_passWord; //数据库信息:密码string m_databaseName; //数据库信息:库名int m_sql_num; //连接池数量threadpool&lt;http_conn&gt;* m_pool; //线程池int m_thread_num; //线程数量epoll_event events[MAX_EVENT_NUMBER]; //epoll调用返回的事件集合int m_epollfd; //epoll文件描述符int m_listenfd; //监听文件描述符int m_OPT_LINGER; //优雅关闭连接int m_LISTENTrigmode; //listenfd触发模式int m_CONNTrigmode; //connfd触发模式client_data* users_timer; //定时器资源Utils utils; //定时器对象http_conn* users; //http解析对象int m_port; //端口号char* m_root; //root资源路径int m_log_write; //异步日志int m_close_log; //关闭日志int m_actormodel; //工作模式int m_pipefd[2]; //管道 类的构造函数123456789101112131415161718192021 WebServer::WebServer()&#123; users = new http_conn[MAX_FD]; m_root=getcwd(nullptr,256); assert(m_root); strncat(m_root,&quot;/root&quot;,6); users_timer = new client_data[MAX_FD]; m_port = 9006; //端口号，默认9006 m_sql_num = 8; //数据库连接池数量，默认8 m_thread_num = 8; //线程池内的线程数量，默认8 m_log_write = 0; //日志模式，默认同步 m_OPT_LINGER = 0; //优雅关闭连接，默认不使用 m_LISTENTrigmode=0; //listenfd触发模式，默认LT m_CONNTrigmode=0; //connfd触发模式，默认LT m_close_log = 0; //关闭日志，默认不关闭 m_actormodel = 0; //并发模型，默认是proactor m_user = &quot;root&quot;; //数据库信息:登录名 m_passWord = &quot;1&quot;; //数据库信息:密码 m_databaseName = &quot;yourdb&quot;; //数据库信息:库名&#125; 通过类的构造函数初始化相关变量，生成默认最大事件数的http类对象和定时器。 类的析构函数12345678910 WebServer::~WebServer()&#123; close(m_epollfd); //关闭epoll文件描述符 close(m_listenfd); //关闭监听文件描述符 close(m_pipefd[1]); //关闭管道 close(m_pipefd[0]); delete[] users; //释放http解析资源 delete[] users_timer;//释放定时器资源 delete m_pool; //释放线程池资源&#125; 当类对象离开作用域时，调用析构函数自动释放资源：关闭epoll文件描述符、监听文件描述符，关闭管道，释放http解析资源、定时器资源和线程池资源。 开启日志12345678910 void WebServer::log_write()&#123; if (0 == m_close_log) //日志未关闭 &#123; if (1 == m_log_write) Log::get_instance()-&gt;init(&quot;./ServerLog&quot;, m_close_log, 2000, 800000, 800); //异步 else Log::get_instance()-&gt;init(&quot;./ServerLog&quot;, m_close_log, 2000, 800000, 0); //同步 &#125;&#125; 调用日志类的get_instance函数，通过单例模式返回一个静态类对象，之后调用init函数开启日志，通过参数max_queue_size判断异步&#x2F;同步模式。当其大于0时，说明是异步日志模式，此时创建指定大小的阻塞队列，同时创建新线程，用于从阻塞队列中取出写日志任务。当其不大于0时，不做额外操作。 建立数据库连接池1234567void WebServer::sql_pool()&#123; m_connpool = connection_poll::GetInstance(); m_connpool-&gt;init(&quot;localhost&quot;, m_user, m_passWord, m_databaseName, 3306, m_sql_num, m_close_log); users-&gt;initmysql_result(m_connpool);&#125; 调用GetInstance函数，通过单例模式返回一个静态类对象，之后调用init函数，登录数据库用户名密码，建立指定大小的数据库连接池，最后调用initmysql_result函数，取出数据库内存储的浏览器端的用户名和密码，供后续注册、登录验证。 建立线程池1234void WebServer::thread_pool()&#123; m_pool = new threadpool&lt;http_conn&gt;(m_actormodel, m_connpool, m_thread_num);&#125; 在线程池中创建指定数量的线程，线程执行worker函数，其调用私有工作run函数，run函数从工作队列中取出任务执行，如果队列为空则堵塞等待。 建立epoll监听1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void WebServer::eventListen()&#123; m_listenfd = socket(PF_INET, SOCK_STREAM, 0); assert(m_listenfd &gt;= 0); if (0 == m_OPT_LINGER) &#123; struct linger tmp = &#123;0, 1&#125;; setsockopt(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, sizeof(tmp)); &#125; else if (1 == m_OPT_LINGER) &#123; struct linger tmp = &#123;1, 1&#125;; setsockopt(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, sizeof(tmp)); &#125; int ret = 0; struct sockaddr_in address; bzero(&amp;address, sizeof(address)); address.sin_family = AF_INET; address.sin_addr.s_addr = htonl(INADDR_ANY); address.sin_port = htons(m_port); int flag = 1; setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag)); ret = bind(m_listenfd, (struct sockaddr *)&amp;address, sizeof(address)); assert(ret &gt;= 0); ret = listen(m_listenfd, 5); assert(ret &gt;= 0); utils.init(TIMESLOT); epoll_event events[MAX_EVENT_NUMBER]; m_epollfd = epoll_create(5); assert(m_epollfd != -1); utils.addfd(m_epollfd, m_listenfd, false, m_LISTENTrigmode); http_conn::m_epollfd = m_epollfd; ret = socketpair(PF_UNIX, SOCK_STREAM, 0, m_pipefd); assert(ret != -1); utils.setnonblocking(m_pipefd[1]); utils.addfd(m_epollfd, m_pipefd[0], false, 0); utils.addsig(SIGPIPE, SIG_IGN); utils.addsig(SIGALRM, utils.sig_handler, false); utils.addsig(SIGTERM, utils.sig_handler, false); alarm(TIMESLOT); Utils::u_pipefd = m_pipefd; Utils::u_epollfd = m_epollfd;&#125; 在服务端中，socket通信从创建socket套接字开始，之后调用bind函数绑定本地的IP地址和端口号，再调用listen函数监听客户端发来的连接。其中可以根据m_OPT_LINGER标志判断是否开始优雅关闭连接，默认当调用close函数时会立即返回，这样可能会有未发送的数据。当标志置1时，则调用setsockopt函数设置延迟关闭，即当文件描述符关闭时内核将拖延一段时间，如果缓冲区扔残留数据，进程将处于睡眠状态，直到（a）所有数据发送完且被对方确认，之后进行正常的终止序列（描述字访问计数为0）或（b）延迟时间到。此种情况下，应用程序检查close的返回值是非常重要的，如果在数据发送完并被确认前时间到，close将返回EWOULDBLOCK错误且套接口发送缓冲区中的任何数据都丢失。close的成功返回仅告诉我们发送的数据（和FIN）已由对方TCP确认，它并不能告诉我们对方应用进程是否已读了数据。如果套接口设为非阻塞的，它将不等待close完成。 处理epoll监听事件队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void WebServer::eventLoop()&#123; bool timeout = false; bool stop_server = false; while (!stop_server) &#123; int number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1); if (number &lt; 0 &amp;&amp; errno != EINTR) &#123; LOG_ERROR(&quot;%s&quot;, &quot;epoll failure&quot;); break; &#125; for (int i = 0; i &lt; number; i++) &#123; int sockfd = events[i].data.fd; if (sockfd == m_listenfd) &#123; bool flag = dealclinetdata(); if (false == flag) continue; &#125; else if (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123; util_timer *timer = users_timer[sockfd].timer; deal_timer(timer, sockfd); &#125; else if ((sockfd == m_pipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123; bool flag = dealwithsignal(timeout, stop_server); if (false == flag) LOG_ERROR(&quot;%s&quot;, &quot;dealclientdata failure&quot;); &#125; else if (events[i].events &amp; EPOLLIN) &#123; dealwithread(sockfd); &#125; else if (events[i].events &amp; EPOLLOUT) &#123; dealwithwrite(sockfd); &#125; &#125; if (timeout) &#123; utils.timer_handler(); LOG_INFO(&quot;%s&quot;, &quot;timer tick&quot;); timeout = false; &#125; &#125;&#125; 在eventLoop函数中，服务器主线程调用epoll_wait函数监听是否有事件响应，返回值number为准备就绪事件的数量，当number大于0时，遍历events集合，其内部存放准备就绪的事件。如果是m_listenfd，说明有新的客户连接产生，此时调用dealclientdata函数接收并处理请求；如果与指定信号相与为真，说明是服务器端关闭连接，此时需要移除对应的定时器；如果为m_pipefd[0]，说明有信号产生，此时调用dealwithsignal函数处理信号；如果与EPOLLIN相与为真，说明是客户端发送数据，此时调用dealwithread函数处理http请求数据；如果与EPOLLOUT相与为真，说明需要向客户端发送数据，此时调用dealwithwrite函数处理http响应数据。 处理新的客户端连接123456789101112131415161718192021222324252627282930313233343536373839404142bool WebServer::dealclinetdata()&#123; struct sockaddr_in client_address; socklen_t client_addrlength = sizeof(client_address); if (0 == m_LISTENTrigmode) &#123; int connfd = accept(m_listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); if (connfd &lt; 0) &#123; LOG_ERROR(&quot;%s:errno is:%d&quot;, &quot;accept error&quot;, errno); return false; &#125; if (http_conn::m_user_count &gt;= MAX_FD) &#123; utils.show_error(connfd, &quot;Internal server busy&quot;); LOG_ERROR(&quot;%s&quot;, &quot;Internal server busy&quot;); return false; &#125; timer(connfd, client_address); &#125; else &#123; while (1) &#123; int connfd = accept(m_listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength); if (connfd &lt; 0) &#123; LOG_ERROR(&quot;%s:errno is:%d&quot;, &quot;accept error&quot;, errno); break; &#125; if (http_conn::m_user_count &gt;= MAX_FD) &#123; utils.show_error(connfd, &quot;Internal server busy&quot;); LOG_ERROR(&quot;%s&quot;, &quot;Internal server busy&quot;); break; &#125; timer(connfd, client_address); &#125; return false; &#125; return true;&#125; dealclientdata函数用于处理新的客户端连接请求，通过m_LISTENTrigmode标志判断LT&#x2F;ET模式，默认为LT模式，此时无需一次性读完，当标志为1时，表示为ET模式，此时需要一次性读完，所以需要通过while循环调用accept函数接收客户端请求数据，当没有数据可读时结束循环。 处理信号函数1234567891011121314151617181920212223242526272829303132333435bool WebServer::dealwithsignal(bool &amp;timeout, bool &amp;stop_server)&#123; int ret = 0; int sig; char signals[1024]; ret = recv(m_pipefd[0], signals, sizeof(signals), 0); if (ret == -1) &#123; return false; &#125; else if (ret == 0) &#123; return false; &#125; else &#123; for (int i = 0; i &lt; ret; ++i) &#123; switch (signals[i]) &#123; case SIGALRM: &#123; timeout = true; break; &#125; case SIGTERM: &#123; stop_server = true; break; &#125; &#125; &#125; &#125; return true;&#125; dealwithsignal函数用于处理通过管道发送的信号，主要有SIGALRM和SIGTERM信号。 处理http请求数据123456789101112131415161718192021222324252627282930313233343536void WebServer::dealwithread(int sockfd)&#123; util_timer *timer = users_timer[sockfd].timer; if (1 == m_actormodel) &#123; if (timer) adjust_timer(timer); m_pool-&gt;append(users + sockfd, 0); while (true) &#123; if (1 == users[sockfd].improv) &#123; if (1 == users[sockfd].timer_flag) &#123; deal_timer(timer, sockfd); users[sockfd].timer_flag = 0; &#125; users[sockfd].improv = 0; break; &#125; &#125; &#125; else &#123; if (users[sockfd].read_once()) &#123; LOG_INFO(&quot;deal with the client(%s)&quot;, inet_ntoa(users[sockfd].get_address()-&gt;sin_addr)); m_pool-&gt;append_p(users + sockfd); if (timer) adjust_timer(timer); &#125; else deal_timer(timer, sockfd); &#125;&#125; dealwithread函数用于处理http请求数据，m_actormodel标志用于判断工作模式，默认为reactor模型，此时调用append函数将事件放入请求队列中，此时需要传入参数0，将m_state标志置0，表示为读事件；当m_actormodel标志为1时，表示是proactor模型，同样调用append_p函数将事件放入请求队列中。 处理http响应数据1234567891011121314151617181920212223242526272829303132333435void WebServer::dealwithwrite(int sockfd)&#123; util_timer *timer = users_timer[sockfd].timer; if (1 == m_actormodel) &#123; if (timer) adjust_timer(timer); m_pool-&gt;append(users + sockfd, 1); while (true) &#123; if (1 == users[sockfd].improv) &#123; if (1 == users[sockfd].timer_flag) &#123; deal_timer(timer, sockfd); users[sockfd].timer_flag = 0; &#125; users[sockfd].improv = 0; break; &#125; &#125; &#125; else &#123; if (users[sockfd].write()) &#123; LOG_INFO(&quot;send data to the client(%s)&quot;, inet_ntoa(users[sockfd].get_address()-&gt;sin_addr)); if (timer) adjust_timer(timer); &#125; else deal_timer(timer, sockfd); &#125;&#125; dealwithwrite函数用于处理http响应数据，m_actormodel标志用于判断工作模式，默认为reactor模型，此时调用append函数将事件放入请求队列中，此时需要传入参数1，将m_state标志置1，表示为写事件；当m_actormodel标志为1时，表示是proactor模型，此时直接调用write函数。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"WebServer类","slug":"WebServer类","permalink":"http://example.com/tags/WebServer%E7%B1%BB/"}]},{"title":"http处理类","slug":"http处理类","date":"2022-03-20T06:12:14.000Z","updated":"2022-05-29T06:22:58.123Z","comments":true,"path":"2022/03/20/http处理类/","link":"","permalink":"http://example.com/2022/03/20/http%E5%A4%84%E7%90%86%E7%B1%BB/","excerpt":"整体概述浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。","text":"整体概述浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。 基础知识http请求报文HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成： 请求行：用来说明请求类型，要访问的资源以及所使用的HTTP版本。 请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 HOST：给出请求资源所在服务器的域名； User-Agent：HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等； Accept：说明用户代理可处理的媒体类型； Accept-Encoding：说明用户代理支持的内容编码； Accept-Language：说明用户代理能够处理的自然语言集； Content-Type：说明实现主体的媒体类型； Content-Length：说明实现主体的大小； Connection：连接管理，可以是Keep-Alive或close； 空行：请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 主体：请求数据，可以添加任意的其他数据。 http响应报文HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 状态行：由HTTP协议版本号，状态码，状态消息三部分组成。 消息报头：用来说明客户端要使用的一些附加信息。 空行：消息报头后面的空行是必须的。 响应正文：服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 有限状态机有限状态机,也称为FSM(Finite State Machine)，其在任意时刻都处于有限状态集合中的某一状态。当其获得一个输入字符时，将从当前状态转换到另一个状态，或者仍然保持在当前状态。任何一个FSM都可以用状态转换图来描述，图中的节点表示FSM中的一个状态，有向（方向表示从一个初态转换到次态）加权（权表示事件）边表示输入字符时状态的变化。如果图中不存在与当前状态与输入字符对应的有向边，则FSM将进入“消亡状态(Doom State)”，此后FSM将一直保持“消亡状态”。 基础APIepoll创建1int epoll_create(int size) 作用：创建epoll文件描述符； 参数： size：自Linux2.6.8后，size参数被忽略，但是依然要大于0； 返回值：成功则返回epoll文件描述符，失败返回一个负数； epoll注册事件1int epoll_ctl(int epfd,int op,int fd,struct epoll_event* event) 作用：告诉内核要监听什么类型的事件； 参数： epfd：epoll_create函数返回的文件描述符； op：表示动作类型： EPOLL_CTL_ADD：注册新的fd到epfd中； EPOLL_CTL_MOD：修改已经注册的fd的监听事件； EPOLL_CTL_DEL：从epfd中删除一个fd； fd：需要监听的文件描述符。epoll将要监听的文件描述符fd加到红黑树上，红黑树的遍历效率比表更高，创建epfd时，内核同时创建了一个红黑树数据结构，epoll_ctl对红黑树中的每个fd注册管理事件属性。 event：表示感兴趣的事件和被触发的事件，可能的取值有： EPOLLIN：文件描述符可以读； EPOLLOUT：文件描述符可以写； EPOLLPRI：文件描述符有紧急的数可读； EPOLLERR：文件描述符发生错误； EPOLLHUP：文件描述符被挂断； EPOLLET：ET的epoll工作模式； EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里； 返回值：成功时返回0，失败时返回-1，并设置errno； epoll_wait函数1int epoll_wait(int epfd，struct epoll_event * events， int maxevents，int timeout) 作用：等待文件描述符epfd引用的epoll实例上的I&#x2F;O事件。等待注册在epfd上的socket的fd的事件的发生，如果发生则将发生的sokct的fd和事件类型放入到events数组中。并且，将注册在epfd上的socket的fd的事件类型给清空。所以如果下一个循环你还要关注这个socket的fd的话，则需要用epoll_ctl(epfd,EPOLL_CTL_MOD,listenfd,&amp;ev)来重新设置socket的fd的事件类型。这时不用EPOLL_CTL_ADD,因为socket的fd并未清空，只是事件类型清空。 参数： epfd：由epoll_create产生的epoll句柄； events：从内核得到事件的集合； maxevents：内核这个events有多大(数组成员的个数),这个maxevents的值不能大于创建epoll_create()时的size； timeout：超时时间（毫秒，0会立即返回，-1将永久阻塞），当超过timeout还没有事件触发时，就超时； 返回值：需要处理的事件数目，若返回0表示已超时； recv函数1int recv(SOCKET s,char FAR* buf,int len,int flags) 作用：从TCP连接的另一端接收数据； 参数： s：指定接收端套接字描述符； buf：指明缓冲区，用来存放接收到的数据； len：缓冲区的长度； flags：一般置0； 返回值：执行成功后返回接收到的字节数，失败则返回-1，并成功设置errno为以下某个值： EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时； EBADF：sock不是有效的描述词； ECONNREFUSE：远程主机阻绝网络连接； EFAULT：内存空间访问出错； EINTR：操作被信号中断； EINVAL：参数无效； ENOMEM：内存不足； ENOTCONN：与面向连接关联的套接字尚未被连接上； ENOTSOCK：sock索引的不是套接字； stat函数1234567891011121314151617int stat(const char * file_name, struct stat *buf);struct stat&#123; dev_t st_dev; //device 文件的设备编号 ino_t st_ino; //inode 文件的i-node mode_t st_mode; //protection 文件的类型和存取的权限 nlink_t st_nlink; //number of hard links 连到该文件的硬连接数目, 刚建立的文件值为1. uid_t st_uid; //user ID of owner 文件所有者的用户识别码 gid_t st_gid; //group ID of owner 文件所有者的组识别码 dev_t st_rdev; //device type 若此文件为装置设备文件, 则为其设备编号 off_t st_size; //total size, in bytes 文件大小, 以字节计算 unsigned long st_blksize; //blocksize for filesystem I/O 文件系统的I/O 缓冲区大小. unsigned long st_blocks; //number of blocks allocated 占用文件区块的个数, 每一区块大小为512 个字节. time_t st_atime; //time of lastaccess 文件最近一次被存取或被执行的时间, 一般只有在用mknod、utime、read、write 与tructate 时改变. time_t st_mtime; //time of last modification 文件最后一次被修改的时间, 一般只有在用mknod、utime 和write 时才会改变 time_t st_ctime; //time of last change i-node 最近一次被更改的时间, 此参数会在文件所有者、组、权限被更改时更新&#125;; 作用：将参数file_name所指的文件状态, 复制到参数buf所指的结构中； 参数： file_name：文件指针； buf：结构体； 返回值：执行成功则返回0，失败返回-1，错误代码存于errno： ENOENT：参数file_name 指定的文件不存在； ENOTDIR：路径中的目录存在但却非真正的目录； ELOOP：欲打开的文件有过多符号连接问题, 上限为16符号连接； EFAULT：参数buf为无效指针, 指向无法存在的内存空间； EACCESS：存取文件时被拒绝； ENOMEM：核心内存不足； ENAMETOOLONG：参数file_name的路径名称太长； 内存映射函数内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。 1void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize); 作用：将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写； 参数： start：指向欲对应的内存起始地址，通常设为NULL，代表让系统自动选定地址，对应成功后该地址会返回； length：代表将文件中多大的部分对应到内存； prot：代表映射区域的保护方式，有下列组合： PROT_EXEC：映射区域可被执行； PROT_READ：映射区域可被读取； PROT_WRITE：映射区域可被写入； PROT_NONE：映射区域不能存取； flags：会影响映射区域的各种特性： MAP_FIXED：如果参数 start 所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标； MAP_SHARED：对应射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享； MAP_PRIVATE：对应射区域的写入操作会产生一个映射文件的复制，即私人的”写入时复制” (copy on write)对此区域作的任何修改都不会写回原来的文件内容； MAP_ANONYMOUS：建立匿名映射，此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享； MAP_DENYWRITE：只允许对应射区域的写入操作，其他对文件直接写入的操作将会被拒绝； MAP_LOCKED：将映射区域锁定住，这表示该区域不会被置换(swap)； fd：open()返回的文件描述词，代表欲映射到内存的文件； offsize：文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍； 返回值：若映射成功则返回映射区的内存起始地址，否则返回-1，错误原因存于errno中： EBADF：参数fd不是有效的文件描述词； EACCES：存取权限有误； EINVAL：参数start、length或offset有一个不合法； EAGAIN：文件被锁住，或是有太多内存被锁住； ENOMEM：内存不足； 1int munmap(void* start,size_t length); 作用：取消内存映射； 参数： start：指向映射内存起始地址； length：欲取消的内存大小； 返回值：如果解除映射成功则返回0，否则返回-1，错误原因存于errno中； writev函数123456ssize_t writev(int filedes,const struct iovec* iov,int iovcnt);struct iovec&#123; void* iov_base; size_t iov_len;&#125; 作用：在一次函数调用中写多个非连续缓冲区，即以顺序iov[0]、iov[1]至iov[iovcnt-1]从缓冲区中聚集输出数据。 参数： filedes：文件描述符； iov：iovec类型结构体： iov_base：指向数据的地址； iov_len：数据的长度； iovcnt：结构体的个数； 返回值：成功则返回已写的字节数，若出错则返回-1; vsnprintf函数1int vsnprintf(char* s,size_t n,const char* format,va_list arg); 作用：将格式化的数据从变量参数列表写入大小已设置的缓冲区； 参数： s：指向存储结果的缓冲区指针； n：缓冲区中要使用的最大字节数； format：包含格式字符串的C字符串； arg：初始化的变量参数列表，使用方法如下： 首先在函数里定义一个va_list型的变量，这个变量是指向参数的指针； 然后用va_start宏初始化变量刚定义的va_list变量； 然后用va_arg返回可变的参数，va_arg的第二个参数是你要返回的参数的类型（如果函数有多个可变参数的，依次调用va_arg获取各个参数）； 最后用va_end宏结束可变参数的获取； 返回值：返回写入的字符数，失败则返回负数； 核心代码分析http类成员变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static const int FILENAME_LEN=200; //文件名长度static const int READ_BUFFER_SIZE=2048; //读缓冲区大小static const int WRITE_BUFFER_SIZE=1024; //写缓冲区大小static int m_epollfd;static int m_user_count;MYSQL* mysql;int m_state; //读为0，写为1int m_sockfd;sockaddr_in m_address;char m_read_buf[READ_BUFFER_SIZE]; //存储读取的请求报文数据int m_read_idx; //读缓冲区中数据的最后一个字节的下一个位置int m_checked_idx; //读缓冲区中读取的位置int m_start_line; //读缓冲区中已经解析的字符个数char m_write_buf[WRITE_BUFFER_SIZE]; //存储的响应报文数据int m_write_idx; //写缓冲区中的数据长度CHECK_STATE m_check_state; //主状态机的状态METHOD m_method; //请求方法//解析请求报文中对应的6个变量char m_real_file[FILENAME_LEN]; //存储读取文件的名称char* m_url;char* m_version;char* m_host;int m_content_length;bool m_linger;int bytes_to_send;int bytes_have_send; //已发送的字节数char* m_string; //存储请求头数据int cgi; //是否启用的POSTstruct stat m_file_stat; //文件结构 struct iovec m_iv[2]; //每一个元素指向一个缓冲区int m_iv_count;char* m_file_address; //文件地址char* doc_root; //网站根目录，文件夹内存放请求的资源和跳转的html文件//将表中的用户名和密码放入map中map&lt;string,string&gt; users;int m_TRIGMode;int m_close_log;char sql_user[100];char sql_passwd[100];char sql_name[100];//报文的请求方法enum METHOD&#123;GET=0,POST,HEAD,PUT,DELETE,TRACE,OPTIONS,CONNECT,PATH&#125;;//主状态机的状态：解析请求行、解析请求头、解析消息体enum CHECK_STATE&#123;CHECK_STATE_REQUESTLINE=0,CHECK_STATE_HEADER,CHECK_STATE_CONTENT&#125;;//报文解析的结果：请求不完整、获得了完整的HTTP请求、请求资源不存在、HTTP请求报文有错误或请求资源为目录、请求资源禁止访问、请求资源可以正常访问、服务器内部错误enum HTTP_CODE&#123;NO_REQUEST,GET_REQUEST,NO_RESOURCE,BAD_REQUEST,FORBIDDEN_REQUEST,FILE_REQUEST,INTERNAL_ERROR,CLOSED_CONNECTION&#125;;//从状态机的状态：完整读取一行、报文语法有误、读取的行不完整enum LINE_STATUS&#123;LINE_OK=0,LINE_BAD,LINE_OPEN&#125;; 初始化数据库连接123456789101112131415161718void http_conn::initmysql_result(connection_poll* connPool)&#123; MYSQL *mysql = NULL; connectionRAII mysqlcon(&amp;mysql, connPool); if (mysql_query(mysql, &quot;SELECT username,passwd FROM user&quot;)) &#123; LOG_ERROR(&quot;SELECT error:%s\\n&quot;, mysql_error(mysql)); &#125; MYSQL_RES *result = mysql_store_result(mysql); int num_fields = mysql_num_fields(result); MYSQL_FIELD *fields = mysql_fetch_fields(result); while (MYSQL_ROW row = mysql_fetch_row(result)) &#123; string temp1(row[0]); string temp2(row[1]); users[temp1] = temp2; &#125;&#125; 先从数据库连接池中取一个数据库连接，然后在user表中检索username、passwd数据（此数据是通过用户在浏览器端注册后，添加至数据库中），将对应的用户名和密码存入map中，供后续登录验证。 初始化http类对象1234567891011121314151617void http_conn::init(int sockfd, const sockaddr_in &amp;addr, char *root, int TRIGMode, int close_log, string user, string passwd, string sqlname)&#123; m_sockfd = sockfd; m_address = addr; addfd(m_epollfd, sockfd, true, m_TRIGMode); m_user_count++; doc_root = root; m_TRIGMode = TRIGMode; m_close_log = close_log; strcpy(sql_user, user.c_str()); strcpy(sql_passwd, passwd.c_str()); strcpy(sql_name, sqlname.c_str()); init(); &#125; 初始化http类对象，将sockfd添加到epollfd中，并开启oneshot事件，同步root目录位置等信息，并且调用私有初始化函数，用于初始化诸多成员变量，例如初始化读写缓冲区、存储文件，将状态初始化为分析请求行状态等。 一次性读函数123456789101112131415161718192021222324252627282930313233bool http_conn::read_once()&#123; if(m_read_idx&gt;=READ_BUFFER_SIZE) return false; int bytes_read=0; if(m_TRIGMode==0) &#123; bytes_read=recv(m_sockfd,m_read_buf+m_read_idx,READ_BUFFER_SIZE-m_read_idx,0); m_read_idx+=bytes_read; if(bytes_read&lt;=0) return false; return true; &#125; else &#123; while(true) &#123; bytes_read=recv(m_sockfd,m_read_buf+m_read_idx,READ_BUFFER_SIZE-m_read_idx,0); if(bytes_read==-1) &#123; if(errno==EAGAIN||errno==EWOULDBLOCK) break; return false; &#125; else if(bytes_read==0) return false; m_read_idx+=bytes_read; &#125; return true; &#125;&#125; 调用read_once函数读取浏览器端发送来的请求报文，直到无数据可读或对方关闭连接，读取到m_read_buffer中，并更新m_read_index。m_TRIGMode为LT&#x2F;ET模式切换标志，为0时表示处于LT模式，此时不需要一次性读完全部数据，因为epoll会一直通知此文件描述符仍有文件可读；为1时表示处于ET模式，此时如果一次性未把数据读完，后续不会再进行通知，需要需要通过while循环不断读取数据，直到无数据可读。 处理http请求报文函数12345678910111213141516171819202122232425262728293031323334353637383940414243http_conn::HTTP_CODE http_conn::process_read()&#123; LINE_STATUS line_status=LINE_OK; HTTP_CODE ret=NO_REQUEST; char* text=0; while((m_check_state==CHECK_STATE_CONTENT&amp;&amp;line_status==LINE_OK)||((line_status=parse_line())==LINE_OK)) &#123; text=get_line(); m_start_line=m_checked_idx; LOG_INFO(&quot;%s&quot;,text); switch(m_check_state) &#123; case CHECK_STATE_REQUESTLINE: &#123; ret=parse_request_line(text); if(ret==BAD_REQUEST) return BAD_REQUEST; break; &#125; case CHECK_STATE_HEADER: &#123; ret=parse_headers(text); if(ret==BAD_REQUEST) return BAD_REQUEST; else if(ret==GET_REQUEST) return do_request(); break; &#125; case CHECK_STATE_CONTENT: &#123; ret=parse_content(text); if(ret==GET_REQUEST) return do_request(); line_status=LINE_OPEN; break; &#125; default: return INTERNAL_ERROR; &#125; &#125; return NO_REQUEST;&#125; process_read函数通过while循环，将主从状态机进行封装，对报文的每一行进行循环处理。循环有两个判断条件，一是主状态机转移到CHECK_STATE_CONTENT，该条件涉及解析消息体；二是从状态机转移到LINE_OK，该条件涉及解析请求行和请求头部。两个条件为或关系，满足一个即可。在while循环体中，使用从状态机读取数据，调用get_line函数，通过m_start_line将从状态机读取数据间接赋给text，而主状态机解析text。parse_request_line为解析请求行函数，parse_headers为解析请求头函数，parse_content为解析消息体函数，do_request为处理http响应函数。 从状态机函数12345678910111213141516171819202122232425262728293031http_conn::LINE_STATUS http_conn::parse_line()&#123; char temp; for (; m_checked_idx &lt; m_read_idx; ++m_checked_idx) &#123; temp = m_read_buf[m_checked_idx]; if (temp == &#x27;\\r&#x27;) &#123; if ((m_checked_idx + 1) == m_read_idx) return LINE_OPEN; else if (m_read_buf[m_checked_idx + 1] == &#x27;\\n&#x27;) &#123; m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;; m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;; return LINE_OK; &#125; return LINE_BAD; &#125; else if (temp == &#x27;\\n&#x27;) &#123; if (m_checked_idx &gt; 1 &amp;&amp; m_read_buf[m_checked_idx - 1] == &#x27;\\r&#x27;) &#123; m_read_buf[m_checked_idx - 1] = &#x27;\\0&#x27;; m_read_buf[m_checked_idx++] = &#x27;\\0&#x27;; return LINE_OK; &#125; return LINE_BAD; &#125; &#125; return LINE_OPEN;&#125; http请求报文中，每一行的数据由\\r\\n作为结束字符，空行只有\\r\\n，因此可以通过查找\\r\\n将报文拆解成单独的行进行解析。从状态机负责读取缓冲区中的数据，并将每行数据末尾的\\r\\n置为\\0\\0，然后更新从状态机在缓冲区中读取的位置m_checked_index，以此来驱动主状态机解析。 从状态机从m_read_buf中逐字节读取，判断当前字节是否为\\r 接下来的字符是\\n，将\\r\\n修改成\\0\\0，将m_checked_idx指向下一行的开头，则返回LINE_OK 接下来达到了buffer末尾，表示buffer还需要继续接收，返回LINE_OPEN 否则，表示语法错误，返回LINE_BAD 当前字节不是\\r，判断是否是\\n（一般是上次读取到\\r就到了buffer末尾，没有接收完整，再次接收时会出现这种情况） 如果前一个字符是\\r，则将\\r\\n修改成\\0\\0，将m_checked_idx指向下一行的开头，则返回LINE_OK 当前字节既不是\\r，也不是\\n 表示接收不完整，需要继续接收，返回LINE_OPEN 解析http请求行函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849http_conn::HTTP_CODE http_conn::parse_request_line(char* text)&#123; m_url=strpbrk(text,&quot; \\t&quot;); if(!m_url) &#123; return BAD_REQUEST; &#125; *m_url++=&#x27;\\0&#x27;; char* method=text; if(strcasecmp(method,&quot;GET&quot;)==0) &#123; m_method=GET; &#125; else if(strcasecmp(method,&quot;POST&quot;)==0) &#123; m_method=POST; cgi=1; &#125; else return BAD_REQUEST; m_url+=strspn(m_url,&quot; \\t&quot;); m_version=strpbrk(m_url,&quot; \\t&quot;); if(!m_version) &#123; return BAD_REQUEST; &#125; *m_version++=&#x27;\\0&#x27;; m_version+=strspn(m_version,&quot; \\t&quot;); if(strcasecmp(m_version,&quot;HTTP/1.1&quot;)!=0) &#123; return BAD_REQUEST; &#125; if(strncasecmp(m_url,&quot;http://&quot;,7)==0) &#123; m_url+=7; m_url=strchr(m_url,&#x27;/&#x27;); &#125; if(strncasecmp(m_url,&quot;https://&quot;,8)==0) &#123; m_url+=8; m_url=strchr(m_url,&#x27;/&#x27;); &#125; if(!m_url||m_url[0]!=&#x27;/&#x27;) return BAD_REQUEST; if(strlen(m_url)==1) strcat(m_url,&quot;judge.html&quot;); m_check_state=CHECK_STATE_HEADER; return NO_REQUEST;&#125; 主状态机初始状态是CHECK_STATE_REQUESTLINE，通过调用从状态机来驱动主状态机，在主状态机进行解析前，从状态机已经将每一行的末尾\\r\\n符号改为\\0\\0，以便于主状态机直接取出对应字符串进行处理。当主状态机处于初始状态CHECK_STATE_REQUESTLINE，调用parse_request_line函数解析请求行，解析函数从m_read_buf中解析HTTP请求行，获得请求方法、目标URL及HTTP版本号，解析完成后主状态机的状态变为CHECK_STATE_HEADER。 解析http请求头函数12345678910111213141516171819202122232425262728293031323334http_conn::HTTP_CODE http_conn::parse_headers(char* text)&#123; if(text[0]==&#x27;\\0&#x27;) &#123; if(m_content_length!=0) &#123; m_check_state=CHECK_STATE_CONTENT; return NO_REQUEST; &#125; return GET_REQUEST; &#125; else if(strncasecmp(text,&quot;Connection:&quot;,11)==0) &#123; text+=11; text+=strspn(text,&quot; \\t&quot;); if(strcasecmp(text,&quot;keep-alive&quot;)==0) m_linger=true; &#125; else if(strncasecmp(text,&quot;Content-length:&quot;,15)==0) &#123; text+=15; text+=strspn(text,&quot; \\t&quot;); m_content_length=atol(text); &#125; else if(strncasecmp(text,&quot;Host:&quot;,5)==0) &#123; text+=5; text+=strspn(text,&quot; \\t&quot;); m_host=text; &#125; else LOG_INFO(&quot;oop!unknow header: %s&quot;,text); return NO_REQUEST;&#125; 当主状态机处于CHECK_STATE_HEADER状态时，调用parse_headers函数解析请求头部信息。判断是空行还是请求头，若是空行，进而判断content-length是否为0，如果不是0，表明是POST请求，则状态转移到CHECK_STATE_CONTENT，否则说明是GET请求，则报文解析结束。若解析的是请求头部字段，则主要分析connection字段，content-length字段。connection字段判断是keep-alive还是close，决定是长连接还是短连接，content-length字段，这里用于读取post请求的消息体长度。 解析http请求主体函数12345678910http_conn::HTTP_CODE http_conn::parse_content(char* text)&#123; if(m_read_idx&gt;=(m_content_length+m_checked_idx)) &#123; text[m_content_length]=&#x27;\\0&#x27;; m_string=text; return GET_REQUEST; &#125; return NO_REQUEST;&#125; 当主状态机处于CHECK_STATE_CONTENT状态时，调用parse_content函数解析消息体，主要是保存post请求消息体，为后面的登录和注册做准备。 处理http请求函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102http_conn::HTTP_CODE http_conn::do_request()&#123; strcpy(m_real_file,doc_root); int len=strlen(doc_root); const char* p=strrchr(m_url,&#x27;/&#x27;); if(cgi==1&amp;&amp;(*(p+1)==&#x27;2&#x27;||*(p+1)==&#x27;3&#x27;)) &#123; char flag=m_url[1]; char* m_url_real=(char*)malloc(sizeof(char)*200); strcpy(m_url_real,&quot;/&quot;); strcat(m_url_real,m_url+2); strncpy(m_real_file+len,m_url_real,FILENAME_LEN-len-1); free(m_url_real); char name[100],password[100]; int i; for(i=5;m_string[i]!=&#x27;&amp;&#x27;;i++) &#123; name[i-5]=m_string[i]; &#125; name[i-5]=&#x27;\\0&#x27;; int j=0; for(i=i+10;m_string[i]!=&#x27;\\0&#x27;;i++,j++) &#123; password[j]=m_string[i]; &#125; password[j]=&#x27;\\0&#x27;; if(*(p+1)==&#x27;3&#x27;) &#123; char* sql_insert=(char*)malloc(sizeof(char)*200); strcpy(sql_insert,&quot;INSERT INTO user(username,passwd) VALUES(&quot;); strcat(sql_insert,&quot;.&quot;); strcat(sql_insert,name); strcat(sql_insert,&quot;&#x27;, &#x27;&quot;); strcat(sql_insert,password); strcat(sql_insert,&quot;&#x27;)&quot;); if(users.find(name)==users.end()) &#123; m_lock.lock(); int res=mysql_query(mysql,sql_insert); users.insert(pair&lt;string,string&gt;(name,password)); m_lock.unlock(); strcpy(m_url,&quot;/log.html&quot;); &#125; else strcpy(m_url,&quot;/registerError.html&quot;); &#125; else if(*(p+1)==&#x27;2&#x27;) &#123; if(users.find(name)!=users.end()&amp;&amp;users[name]==password) strcpy(m_url,&quot;/welcome.html&quot;); else strcpy(m_url,&quot;/logError.html&quot;); &#125; &#125; if(*(p+1)==&#x27;0&#x27;) &#123; char* m_url_real=(char*)malloc(sizeof(char)*200); strcpy(m_url_real,&quot;/register.html&quot;); strncpy(m_real_file+len,m_url_real,strlen(m_url_real)); free(m_url_real); &#125; else if(*(p+1)==&#x27;1&#x27;) &#123; char* m_url_real=(char*)malloc(sizeof(char)*200); strcpy(m_url_real,&quot;/log.html&quot;); strncpy(m_real_file+len,m_url_real,strlen(m_url_real)); free(m_url_real); &#125; else if(*(p+1)==&#x27;5&#x27;) &#123; char* m_url_real=(char*)malloc(sizeof(char)*200); strcpy(m_url_real,&quot;/picture.html&quot;); strncpy(m_real_file+len,m_url_real,strlen(m_url_real)); free(m_url_real); &#125; else if(*(p+1)==&#x27;6&#x27;) &#123; char* m_url_real=(char*)malloc(sizeof(char)*200); strcpy(m_url_real,&quot;/video.html&quot;); strncpy(m_real_file+len,m_url_real,strlen(m_url_real)); free(m_url_real); &#125; else strncpy(m_real_file+len,m_url,FILENAME_LEN-len-1); if(stat(m_real_file,&amp;m_file_stat)&lt;0) return NO_RESOURCE; if(!(m_file_stat.st_mode&amp;S_IROTH)) return FORBIDDEN_REQUEST; if(S_ISDIR(m_file_stat.st_mode)) return BAD_REQUEST; int fd=open(m_real_file,O_RDONLY); m_file_address=(char*)mmap(0,m_file_stat.st_size,PROT_READ,MAP_PRIVATE,fd,0); close(fd); return FILE_REQUEST;&#125; process_read函数的返回值是对请求的文件分析后的结果，一部分是语法错误导致的BAD_REQUEST，一部分是do_request的返回结果。该函数将网站根目录和url文件拼接，然后通过stat判断该文件属性。另外，为了提高访问速度，通过mmap进行映射，将普通文件映射到内存逻辑地址。m_url为请求报文中解析出的请求资源，以&#x2F;开头，也就是&#x2F;XXX，项目中解析后的m_url有8种情况： GET请求，跳转到欢迎访问页面 0：POST请求，跳转到注册页面 1：POST请求，跳转到登录页面 2CGISQL.cgi：POST请求，进行登录校验，验证成功跳转到资源请求成功页面，失败则跳转到登录失败页面 3CGISQL.cgi：POST请求，进行注册校验，注册成功跳转到登录页面，失败则跳转到注册失败页面 5：POST请求，跳转到图片请求页面 6：POST请求，跳转到视频请求页面 在解析http请求函数中已经保存了浏览器端用户输入的用户密码，在http请求处理函数中，提取出用户名和密码，然后判断是注册还是登录，如果是注册，先检测数据库中是否有重名，没有重名则直接增加数据，如果是登录，进行判断，若浏览器端输入的用户名和密码在表中可以查找到，返回1，否则返回0。 写响应报文函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool http_conn::process_write(HTTP_CODE ret)&#123; switch(ret) &#123; case INTERNAL_ERROR: &#123; add_status_line(500,error_500_title); add_headers(strlen(error_500_form)); if(!add_content(error_500_form)) return false; break; &#125; case BAD_REQUEST: &#123; add_status_line(404,error_400_title); add_headers(strlen(error_400_form)); if(!add_content(error_400_form)) return false; break; &#125; case FORBIDDEN_REQUEST: &#123; add_status_line(403,error_403_title); add_headers(strlen(error_403_form)); if(!add_content(error_403_form)) return false; break; &#125; case FILE_REQUEST: &#123; add_status_line(200,ok_200_title); if(m_file_stat.st_size!=0) &#123; add_headers(m_file_stat.st_size); m_iv[0].iov_base=m_write_buf; m_iv[0].iov_len=m_write_idx; m_iv[1].iov_base=m_file_address; m_iv[1].iov_len=m_file_stat.st_size; m_iv_count=2; bytes_to_send=m_write_idx+m_file_stat.st_size; return true; &#125; else &#123; const char* ok_string=&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;; add_headers(strlen(ok_string)); if(!add_content(ok_string)) return false; &#125; &#125; default: return false; &#125; m_iv[0].iov_base=m_write_buf; m_iv[0].iov_len=m_write_idx; m_iv_count=1; bytes_to_send=m_write_idx; return true;&#125; 响应报文分为两种，一种是请求文件的存在，通过io向量机制iovec，声明两个iovec，第一个指向m_write_buf，第二个指向mmap的地址m_file_address；一种是请求出错，这时候只申请一个iovec，指向m_write_buf。请求出错包括内部错误（500）、报文语法有误（404）、资源没有访问权限（403），请求文件存在则是文件存在（200）。该函数调用了三个写响应报文函数，add_status_line函数——添加状态行，add_headers——添加消息报头，add_content函数——添加文本。 写状态行、消息报头函数123456789101112bool http_conn::add_status_line(int status,const char* title)&#123; return add_response(&quot;%s %d %s\\r\\n&quot;,&quot;HTTP/1.1&quot;,status,title);&#125;bool http_conn::add_headers(int content_len)&#123; return add_content_length(content_len)&amp;&amp;add_linger()&amp;&amp;add_blank_line();&#125;bool http_conn::add_content(const char* content)&#123; return add_response(&quot;%s&quot;,content);&#125; add_headers函数接收报文长度为参数，内部又调用add_content_length函数（添加响应报文长度）、add_linger函数（添加通知状态，告诉浏览器端是保持连接或者关闭）、add_blank_line函数（添加空行）。 123456789101112bool http_conn::add_content_length(int content_len)&#123; return add_response(&quot;Content-Length:%d\\r\\n&quot;,content_len);&#125;bool http_conn::add_linger()&#123; return add_response(&quot;Connection:%s\\r\\n&quot;,(m_linger==true)?&quot;keep-alive&quot;:&quot;close&quot;);&#125;bool http_conn::add_blank_line()&#123; return add_response(&quot;%s&quot;,&quot;\\r\\n&quot;);&#125; 以上写http响应函数都调用同一个函数add_response，通过引入不同参数实现不同功能。 123456789101112131415161718bool http_conn::add_response(const char* format,...)&#123; if(m_write_idx&gt;=WRITE_BUFFER_SIZE) return false; va_list arg_list; va_start(arg_list,format); int len=vsnprintf(m_write_buf+m_write_idx,WRITE_BUFFER_SIZE-1-m_write_idx,format,arg_list); if(len&gt;=(WRITE_BUFFER_SIZE-1-m_write_idx)) &#123; va_end(arg_list); return false; &#125; m_write_idx+=len; va_end(arg_list); LOG_INFO(&quot;request:%s&quot;,m_write_buf); return true;&#125; 调用add_response函数更新m_write_index指针和缓冲区m_write_buf中的内容。如果写入内容超出缓冲区大小则报错。将数据从可变参数写入缓冲区，返回写入数据的长度，如果写入的数据长度超过缓冲区剩余空间则报错，否则更新m_write_idx位置。 服务器主线程写响应函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bool http_conn::write()&#123; int temp=0; if(bytes_to_send==0) &#123; modfd(m_epollfd,m_sockfd,EPOLLIN,m_TRIGMode); init(); return true; &#125; while(1) &#123; temp=writev(m_sockfd,m_iv,m_iv_count); if (temp &lt; 0) &#123; if (errno == EAGAIN) &#123; modfd(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode); return true; &#125; unmap(); return false; &#125; bytes_have_send += temp; bytes_to_send -= temp; if (bytes_have_send &gt;= m_iv[0].iov_len) &#123; m_iv[0].iov_len = 0; m_iv[1].iov_base = m_file_address + (bytes_have_send - m_write_idx); m_iv[1].iov_len = bytes_to_send; &#125; else &#123; m_iv[0].iov_base = m_write_buf + bytes_have_send; m_iv[0].iov_len = m_iv[0].iov_len - bytes_have_send; &#125; if(bytes_to_send&lt;=0) &#123; unmap(); modfd(m_epollfd,m_sockfd,EPOLLIN,m_TRIGMode); if(m_linger) &#123; init(); return true; &#125; else return false; &#125; &#125;&#125; 服务器子线程调用process_write完成响应报文，随后注册epollout事件，服务器主线程检测写事件，并调用http_conn::write函数将响应报文发送给浏览器端。在生成响应报文时初始化byte_to_send，包括头部信息和文件数据大小。通过writev函数循环发送响应报文数据，根据返回值更新byte_have_send和iovec结构体的指针和长度，并判断响应报文整体是否发送成功。 若writev单次发送成功，更新byte_to_send和byte_have_send的大小，若响应报文整体发送成功，则取消mmap映射，并判断是否是长连接； 长连接重置http类实例，注册读事件，不关闭连接； 短连接直接关闭连接； 若writev单次发送不成功，判断是否是写缓冲区满了； 若不是因为缓冲区满了而失败，取消mmap映射，关闭连接； 若eagain则满了，更新iovec结构体的指针和长度，并注册写事件，等待下一次写事件触发（当写缓冲区从不可写变为可写，触发epollout），因此在此期间无法立即接收到同一用户的下一请求，但可以保证连接的完整性。 http工作函数12345678910111213void http_conn::process()&#123; HTTP_CODE read_ret=process_read(); if(read_ret==NO_REQUEST) &#123; modfd(m_epollfd,m_sockfd,EPOLLIN,m_TRIGMode); return; &#125; bool write_ret=process_write(read_ret); if(!write_ret) close_conn(); modfd(m_epollfd,m_sockfd,EPOLLOUT,m_TRIGMode);&#125; http类对象的工作函数，先调用process_read函数读取http请求，当请求不完整则需要继续接收请求数据，注册并监听读事件。如果请求完整则调用process_write完成报文响应，最后注册并监听写事件。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"http处理类","slug":"http处理类","permalink":"http://example.com/tags/http%E5%A4%84%E7%90%86%E7%B1%BB/"}]},{"title":"定时器","slug":"定时器","date":"2022-03-15T03:45:35.000Z","updated":"2022-05-29T06:23:05.929Z","comments":true,"path":"2022/03/15/定时器/","link":"","permalink":"http://example.com/2022/03/15/%E5%AE%9A%E6%97%B6%E5%99%A8/","excerpt":"整体概述服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。本项目利用alarm函数周期性触发SIGALRM信号，信号处理函数利用管道通知主循环，主循环接受到该信号后对升序链表上所有定时器进行处理。若该段时间内没有交换出具，则将该连接关闭，释放所占用的资源。","text":"整体概述服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。本项目利用alarm函数周期性触发SIGALRM信号，信号处理函数利用管道通知主循环，主循环接受到该信号后对升序链表上所有定时器进行处理。若该段时间内没有交换出具，则将该连接关闭，释放所占用的资源。 基础知识定时事件：固定一段时间之后触发某段代码，由该段代码处理一个事件。非活跃事件：客户端与服务器端建立连接后，长时间不交换数据，一直占用服务端的文件描述符，导致连接资源的浪费。定时器：将定时事件与连接资源封装为一个结构体定时器。 基础APIepoll_event结构体用于注册所感兴趣的事件和回传所发送待处理的事件，定义如下 123456789101112typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;&#125; epoll_data_t;//保存触发事件的某个文件描述符相关的数据struct epoll_event &#123; __uint32_t events; /* epoll event */ epoll_data_t data; /* User data variable */&#125;; 其中events表示感兴趣的事件和被触发的事件，可能的取值有： EPOLLIN：文件描述符可以读； EPOLLOUT：文件描述符可以写； EPOLLPRI：文件描述符有紧急的数可读； EPOLLERR：文件描述符发生错误； EPOLLHUP：文件描述符被挂断； EPOLLET：ET的epoll工作模式； LT&#x2F;ET工作模式与poll的事件宏相比，epoll新增了一个事件宏EPOLLET，这就是所谓的边缘触发模式（Edge Trigger，ET），而默认的模式我们称为水平触发模式（Level Trigger，LT）。这两种模式的区别在于：对于水平触发模式，一个事件只要有，就会一直触发；对于边缘触发模式，只有一个事件从无到有才会触发。这两个词汇来自电学术语，你可以将fd上有数据认为是高电平，没有数据认为是低电平，将fd可写认为是高电平，fd不可写认为是低电平。那么水平模式的触发条件是状态处于高电平，而边缘模式的触发条件是新来一次电信号将当前状态变为高电平。以socket的读事件为例，对于水平模式，只要socket上有未读完的数据，就会一直产生EPOLLIN 事件；而对于边缘模式，socket上每新来一次数据就会触发一次，如果上一次触发后，未将socket上的数据读完，也不会再触发，除非再新来一次数据。也就是说，如果对于一个非阻塞socket，如果使用epoll边缘模式去检测数据是否可读，触发可读事件以后，一定要一次性把socket上的数据收取干净才行，也就是说一定要循环调用recv函数直到recv出错，错误码是EWOULDBLOCK（EAGAIN 一样）（此时表示socket上本次数据已经读完）；如果使用水平模式，则不用，你可以根据业务一次性收取固定的字节数，或者收完为止。 EPOLLONESHOT事件epoll模型的ET模式一般来说只触发一次，然而在并发程序中有特殊情况的存在，譬如当epoll_wait已经检测到socket描述符fd1，并通知应用程序处理fd1的数据，那么处理过程中该fd1又有新的数据可读，会唤醒其他线程对fd1进行操作，那么就出现了两个工作线程同时处理fd1的情况，这当然不是我们期望看到的。而epolloneshot事件规定操作系统最多触发其上注册的一个可读或者可写或者异常事件，且只触发一次，如此无论线程再多，只能有一个线程或进程处理同一个描述符。当然处理完之后线程要重置这个epolloneshot事件，进而当此描述符有事件可读时让其他进程可以处理此描述符。 fcntl函数123int fcntl(int fd, int cmd);int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd, struct flock *lock); 作用：操作文件描述符的一些特性 参数： fd：欲设置的文件描述符 cmd：欲操作的指令 F_DUPFD：用来查找大于或等于参数arg的最小且仍未使用的文件描述词，并且复制参数fd的文件描述词，执行成功则返回新复制的文件描述词； F_GETFD：取得close-on-exec 旗标，若此旗标的FD_CLOEXEC 位为0, 代表在调用exec()相关函数时文件将不会关闭； F_SETFD：设置close-on-exec 旗标，该旗标以参数arg 的FD_CLOEXEC位决定； F_GETFL：取得文件描述词状态旗标，此旗标为open()的参数flags； F_SETFL：设置文件描述词状态旗标，参数arg为新旗标，但只允许O_APPEND、O_NONBLOCK（非阻塞IO）和O_ASYNC位的改变，其他位的改变将不受影响； F_GETLK：取得文件锁定的状态； F_SETLK：设置文件锁定的状态，此时flcok结构的l_type值必须是F_RDLCK、F_WRLCK 或F_UNLCK，如果无法建立锁定，则返回-1，错误代码为EACCES或EAGAIN； F_SETLKW：同F_SETLK作用相同，但是无法建立锁定时，此调用会一直等到锁定动作成功为止，若在等待锁定的过程中被信号中断时，会立即返回-1，错误代码为EINTR，参数lock指针为flock 结构指针； 返回值：成功则返回0，若有错误则返回-1，错误原因存于errno； sigaction函数与结构体1int sigaction(int signum,const struct sigaction *act,const struct sigaction *old); 作用：改变进程接收到特定信号后的行为； 参数： signum：信号的值，可以为除sigkill及sigstop外的任何一个特定有效的信号； act：指向结构sigaction的一个实例的指针，在结构sigaction的实例中，指定了对特定信号的处理，可以为空，进程会以缺省方式对信号处理； old：指向的对象用来保存原来对相应信号的处理，可以传入结构sigaction的指针来获取之前对信号处理情况，如果不需要保存可指定oldact为null。 返回值：函数成功返回0，失败返回-1； 12345678struct sigaction &#123; void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void);&#125; sa_handler：一个函数指针，指向信号处理函数； sa_sigaction：同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息； sa_mask：用来指定在信号处理函数执行期间需要被屏蔽的信号； sa_flags：用于指定信号处理的行为； SA_RESTART：使被信号打断的系统调用自动重新发起； SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到SIGCHLD信号； SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到SIGCHLD信号，这时子进程如果退出也不会成为僵尸进程； SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号； SA_RESETHAND：信号处理之后重新设置为默认的处理方式； SA_SIGINFO：使用sa_sigaction成员而不是sa_handler作为信号处理函数； sa_restorer：一般不使用； 核心代码分析定时器类12345678910class util_timer&#123;public: time_t expire; //超时时间 void (*cb_func)(client_data*); //回调函数 client_data* user_data; //连接资源 util_timer* prev; //前向定时器 util_timer* next; //后继定时器 util_timer():prev(NULL),next(NULL)&#123;&#125;&#125;; 连接资源结构体123456struct client_data&#123; sockaddr_in address; //客户端socket地址 int sockfd; //socket文件描述符 util_timer* timer; //定时器类&#125;; 向定时器链表中添加定时器123456789101112131415161718void sort_timer_lst::add_timer(util_timer* timer)&#123; if(!timer) return; if(!head) &#123; head=tail=timer; return; &#125; if(timer-&gt;expire&lt;head-&gt;expire) &#123; timer-&gt;next=head; head-&gt;prev=timer; head=timer; return; &#125; add_timer(timer,head);&#125; 如果新的定时器超时时间timer-&gt;expire小于当前头部结点超时时间head-&gt;expire，则直接将当前定时器结点作为头部结点。否则就调用私有成员函数add_timer，找出定时器链表中大于新的定时器超时时间的结点，再进行插入操作。 定时任务处理函数123456789101112131415161718void sort_timer_lst::tick()&#123; if(!head) return; time_t cur=time(NULL); util_timer* temp=head; while(temp) &#123; if(cur&lt;temp-&gt;expire) break; temp-&gt;cb_func(temp-&gt;user_data); head=temp-&gt;next; if(head) head-&gt;prev=NULL; delete temp; temp=head; &#125;&#125; 首先获取当前时间，之后通过while循环遍历定时器链表。因为链表为升序排列，所以如果当前时间小于定时器的超时时间，则后面的定时器也没有到期。如果当前定时器到期，则调用回调函数，执行定时事件，并将处理后的定时器从链表容器中删除，重置头结点。 定时器回调函数1234567void cb_func(client_data* user_data)&#123; epoll_ctl(Utils::u_epollfd,EPOLL_CTL_DEL,user_data-&gt;sockfd,0); assert(user_data); close(user_data-&gt;sockfd); http_conn::m_user_count--;&#125; 删除非活动连接在socket上的注册事件，关闭文件描述符，减少连接数。 注册读事件12345678910111213void Utils::addfd(int epollfd, int fd, bool one_shot, int TRIGMode)&#123; epoll_event event; event.data.fd = fd; if (1 == TRIGMode) event.events = EPOLLIN | EPOLLET | EPOLLRDHUP; else event.events = EPOLLIN | EPOLLRDHUP; if (one_shot) event.events |= EPOLLONESHOT; epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event); setnonblocking(fd);&#125; one_shot为是否开始EPOLLONESHOT标志，TRIGMode为ET&#x2F;LT模式切换标志，为1表示ET模式，为0表示LT模式，通过events的异或操作添加相关状态。setnonblocking函数将fd设置为非阻塞状态。 设置信号函数12345678910void Utils::addsig(int sig,void(handler)(int),bool restart)&#123; struct sigaction sa; memset(&amp;sa,&#x27;\\0&#x27;,sizeof(sa)); sa.sa_handler=handler; if(restart) sa.sa_flags|=SA_RESTART; sigfillset(&amp;sa.sa_mask); assert(sigaction(sig,&amp;sa,NULL)!=-1);&#125; addsig函数对sig信号的处理函数设置为handler，当restart标志为真时，添加SA_RESTART信号，表示使被信号打断的系统调用自动重新发起。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"定时器","slug":"定时器","permalink":"http://example.com/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"}]},{"title":"日志系统","slug":"日志","date":"2022-03-11T04:37:24.000Z","updated":"2022-05-29T06:22:42.131Z","comments":true,"path":"2022/03/11/日志/","link":"","permalink":"http://example.com/2022/03/11/%E6%97%A5%E5%BF%97/","excerpt":"整体概述项目中使用单例模式创建日志类对象，对webserver运行状态、错误信息和访问数据进行记录，可以实现按天分类、超行分类功能，并且同时提供同步和异步两种写入方式。异步日志模式中，将生产者-消费者模型封装成阻塞队列，创建一个日志写线程，工作线程把要写入的内容push进队列，写线程从队列中取出内容，写入日志文件。","text":"整体概述项目中使用单例模式创建日志类对象，对webserver运行状态、错误信息和访问数据进行记录，可以实现按天分类、超行分类功能，并且同时提供同步和异步两种写入方式。异步日志模式中，将生产者-消费者模型封装成阻塞队列，创建一个日志写线程，工作线程把要写入的内容push进队列，写线程从队列中取出内容，写入日志文件。 基础知识同步&#x2F;异步日志同步日志：写入日志操作和工作线程串行执行，当单条日志较大时，同步模式会降低服务器所能处理的并发能力异步日志: 先将需要写入的日志内容存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。 生产者-消费者模型生产者消费者模型具体来讲，就是在一个系统中，存在生产者和消费者两种角色，他们通过内存缓冲区进行通信，生产者生产消费者需要的资料，消费者把资料做成产品。再具体一点：生产者生产数据到缓冲区中，消费者从缓冲区中取数据；如果缓冲区已经满了，则生产者线程阻塞；如果缓冲区为空，那么消费者线程阻塞。 阻塞队列阻塞队列是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列不满。支持阻塞的移除方法：当队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。 单例模式单例模式是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 基础APItm结构体123456789101112struct tm&#123; int tm_sec; // 秒：0-59(允许至61) int tm_min; // 分：0-59 int tm_hour; // 时：0-23 int tm_mday; // 日：1-31 int tm_mon; // 月：0-11 int tm_year; // 年：自1900年起的年数 int tm_wday; // 星期：0-6（从星期日算起） int tm_yday; // 一年中的第几天：0-365（从1月1日算起） int tm_isdst; // 夏令时&#125;; time函数1time_t time(time_t* time) 作用：获取或设置系统时间； 参数： time：若给定参数，则将当前时间保存到该参数中，若不给定参数，则为NULL； 返回值：当前日历时间，自1970-01-01到目前的秒数； localtime函数1struct tm* localtime(const time_t* timer) 作用：获取结构体格式的系统时间； 参数： timer：要转化的时间； 返回值：指向结构体tm的指针，该结构体信息被timer填充； gettimeofday函数1int gettimeofday(struct timeval* tv,struct timezone* tz) 作用：获取当前精确时间（1970年1月1日到现在的时间）； 参数： tv：保存获取时间结果的结构体； tz：保存时区结果； 返回值：成功返回0，失败返回-1，并设置相关错误代码； fputs函数1int fputs(char* string,FILE* stream) 作用：将指定的字符串写入到文件流中，从string的开头往文件写入字符串，直到遇见结束符’\\0’，其不会被写入到文件中； 参数： string：将要写入的字符串； stream：文件流指针； 返回值：成功返回非负数，失败返回EOF； snprintf函数1int snprintf(char* str,size_t size,const char* format, ...) 作用：将可变参数按照format格式化成字符串，并将字符串复制到str中，size为要写入的字符的最大数目。如果格式化后的字符串长度小于size，则会把字符串全部复制到str中，并给其后添加一个字符串结束符’\\0’。如果大于size，超过的部分会被截断。 参数： str：目标字符串； size：拷贝字节数； format：格式化成字符串； …：可变参数； 返回值：欲写入的字符串长度； 核心代码分析单例模式通过私有化构造函数，防止外界创建类的对象，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例懒汉模式：在第一次被使用时才进行初始化 123456789101112class single&#123;private: single()&#123;&#125; ~single()&#123;&#125;public: static single* getinstance();&#125;;single* single::getinstance()&#123;static single obj;return &amp;obj;&#125; 饿汉模式：在程序运行时就定义了对象，并对其初始化 12345678910111213class single&#123;private: static single* p; single()&#123;&#125; ~single()&#123;&#125;public: static single* getinstance();&#125;;single* single::p = new single();single* single::getinstance()&#123;return p;&#125; 阻塞队列类成员变量1234567locker m_mutex; //互斥锁cond m_cond; //条件变量T* m_array; //阻塞队列int m_size; //队列内的数量int m_max_size; //队列最大容量int m_front; //队列头int m_back; //队列尾 阻塞队列类中封装了生产者-消费者模型，其中push成员是生产者，pop成员是消费者，当队列为空时，从队列中获取元素的线程将会被挂起，当队列是满时，往队列里添加元素的线程将会挂起 阻塞队列初始化、清除、析构12345678910111213141516171819202122232425block_queue(int max_size=1000)&#123; if(max_size&lt;=0) exit(-1); m_max_size=max_size; m_array=new T[max_size]; m_size=0; m_front=-1; m_back=-1;&#125;void clear()&#123; m_mutex.lock(); m_size=0; m_front=-1; m_back=-1; m_mutex.unlock();&#125;~block_queue()&#123; m_mutex.lock(); if(m_array!=NULL) delete[] m_array; m_mutex.unlock();&#125; 判断阻塞队列是否满、空12345678910111213141516171819202122bool full()&#123; m_mutex.lock(); if(m_size&gt;=m_max_size) &#123; m_mutex.unlock(); return true; &#125; m_mutex.unlock(); return false;&#125;bool empty()&#123; m_mutex.lock(); if(0==m_size) &#123; m_mutex.unlock(); return true; &#125; m_mutex.unlock(); return false;&#125; 返回队首元素、队尾元素、大小、最大值12345678910111213141516171819202122232425262728293031323334353637383940bool front(T&amp; value)&#123; m_mutex.lock(); if(m_size==0) &#123; m_mutex.unlock(); return false; &#125; value=m_array[m_front]; m_mutex.unlock(); return true;&#125;bool back(T&amp; value)&#123; m_mutex.lock(); if(m_size==0) &#123; m_mutex.unlock(); return false; &#125; value=m_array[m_back]; m_mutex.unlock(); return true;&#125;int size()&#123; int temp=0; m_mutex.lock(); temp=m_size; m_mutex.unlock(); return temp;&#125;int max_size()&#123; int temp=0; m_mutex.lock(); temp=m_max_size; m_mutex.unlock(); return temp;&#125; 往队列中添加、删除元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bool push(const T&amp; item)&#123; m_mutex.lock(); if(m_size&gt;=m_max_size) &#123; m_cond.broadcast(); m_mutex.unlock(); return false; &#125; m_back=(m_back+1)%m_max_size; m_array[m_back]=item; m_size++; m_cond.broadcast(); m_mutex.unlock(); return true;&#125;bool pop(T&amp; item)&#123; m_mutex.lock(); while(m_size&lt;=0) &#123; if(m_cond.wait(m_mutex.get())) &#123; m_mutex.unlock(); return false; &#125; &#125; m_front=(m_front+1)%m_max_size; item=m_array[m_front]; m_size--; m_mutex.unlock(); return true;&#125;bool pop(T&amp; item,int ms_timeout)&#123; struct timespec t=&#123;0,0&#125;; struct timeval now=&#123;0,0&#125;; gettimeofday(&amp;now,NULL); m_mutex.lock(); if(m_size&lt;=0) &#123; t.tv_sec=now.tv_sec+ms_timeout/1000; t.tv_nsec=(ms_timeout%1000)*1000; if(!m_cond.timewait(m_mutex.get(),t)) &#123; m_mutex.unlock(); return false; &#125; &#125; if(m_size&lt;=0) &#123; m_mutex.unlock(); return false; &#125; m_front=(m_front+1)%m_max_size; item=m_array[m_front]; m_size--; m_mutex.unlock(); return true; &#125; 往队列中添加元素，需要将所有使用队列的线程先唤醒，当有元素push进队列，相当于生产者生产了一个元素，若当前没有线程等待条件变量，则唤醒无意义。pop时，如果队列没有元素，将会等待条件变量，增加了超时处理，指定时间内能抢到互斥锁即可。 日志类成员变量123456789101112char dir_name[128]; //路径名char log_name[128]; //log文件名int m_split_line; //日志最大行数int m_log_buf_size; //日志缓冲区大小long long m_count; //日志行数记录int m_today; //按天分文件，记录当前时间是哪一天FILE* m_fp; //打开log的文件指针char* m_buf; //要输出的内容block_queue&lt;string&gt;* m_log_queue; //阻塞队列bool m_is_asyns; //是否同步标志位locker m_mutex; //同步类int m_close_log; //关闭日志 日志类对象初始化123456789101112131415161718192021222324252627282930313233bool Log::init(const char* file_name,int close_log,int log_buf_size,int split_lines,int max_queue_size)&#123; if(max_queue_size&gt;=1) &#123; m_is_asyns=true; m_log_queue=new block_queue&lt;string&gt;(max_queue_size); pthread_t tid; pthread_create(&amp;tid,NULL,flush_log_thread,NULL); &#125; m_close_log=close_log; m_log_buf_size=log_buf_size; m_buf=new char[m_log_buf_size]; memset(m_buf,&#x27;\\0&#x27;,m_log_buf_size); m_split_line=split_lines; time_t t=time(NULL); struct tm* sys_tm=localtime(&amp;t); struct tm my_tm=*sys_tm; const char* p=strrchr(file_name,&#x27;/&#x27;); char log_full_name[256]=&#123;0&#125;; if(p==NULL) snprintf(log_full_name,255,&quot;%d_%02d_%02d_%s&quot;,my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday,file_name); else &#123; strcpy(log_name,p+1); strncpy(dir_name,file_name,p-file_name+1); snprintf(log_full_name,255,&quot;%s%d_%02d_%02d_%s&quot;,dir_name,my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday,log_name); &#125; m_today=my_tm.tm_mday; m_fp=fopen(log_full_name,&quot;a&quot;); if(m_fp==NULL) return false; return true;&#125; max_queue_size为阻塞队列的长度，如果不为0，表示使用异步日志模式，此时设置m_is_asyns标志为true，生成指定大小的阻塞队列，创建线程，调用flush_log_thread回调函数，表示创建线程异步写日志。如果为0，表示使用同步日志模式。同时初始化log文件名、日志最大行数、日志缓冲区大小。 异步日志公有方法1234static void* flush_log_thread(void* args)&#123; Log::get_instance()-&gt;async_write_log();&#125; 调用私有方法async_write_log。 异步日志私有方法12345678910void* async_write_log()&#123; string single_log; while(m_log_queue-&gt;pop(single_log)) &#123; m_mutex.lock(); fputs(single_log.c_str(),m_fp); m_mutex.unlock(); &#125;&#125; 从阻塞队列中取出一条日志内容，写入文件，当阻塞队列为空时，线程阻塞等待，直到有新日志插入，唤醒线程。 用于其它文件中使用的日志写宏定义1234#define LOG_DEBUG(format, ...) if(m_close_log==0) &#123;Log::get_instance()-&gt;write_log(0,format,##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_INFO(format, ...) if(m_close_log==0) &#123;Log::get_instance()-&gt;write_log(1,format,##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_WARN(format, ...) if(m_close_log==0) &#123;Log::get_instance()-&gt;write_log(2,format,##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_ERROR(format, ...) if(m_close_log==0) &#123;Log::get_instance()-&gt;write_log(3,format,##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125; 定义四个宏，用于在其它文件中进行日志写操作，其中m_close_log&#x3D;&#x3D;0表示日志未关闭，get_instance函数为通过单例模式实现的日志类对象，write_log函数为写日志的具体逻辑实现，flush函数为刷新写缓冲区。 单例模式的日志类对象实现函数12345static Log* get_instance()&#123; static Log instance; return &amp;instance;&#125; 日志写的逻辑实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void Log::write_log(int level,const char* format, ...)&#123; struct timeval now=&#123;0,0&#125;; gettimeofday(&amp;now,NULL); time_t t=now.tv_sec; struct tm* sys_tm=localtime(&amp;t); struct tm my_tm=*sys_tm; char s[16]=&#123;0&#125;; switch(level) &#123; case 0: strcpy(s,&quot;[debug]:&quot;); break; case 1: strcpy(s,&quot;[info]:&quot;); break; case 2: strcpy(s,&quot;[warn]:&quot;); break; case 3: strcpy(s,&quot;[erro]:&quot;); break; default: strcpy(s,&quot;[info]:&quot;); break; &#125; m_mutex.lock(); m_count++; if(m_today!=my_tm.tm_mday||m_count%m_split_line==0) &#123; char new_log[256]=&#123;0&#125;; fflush(m_fp); fclose(m_fp); char tail[16]=&#123;0&#125;; snprintf(tail,16,&quot;%d_%02d_%02d_&quot;,my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday); if(m_today!=my_tm.tm_mday) &#123; snprintf(new_log,255,&quot;%s%s%s&quot;,dir_name,tail,log_name); m_today=my_tm.tm_mday; m_count=0; &#125; else snprintf(new_log,255,&quot;%s%s%s.%lld&quot;,dir_name,tail,log_name,m_count/m_split_line); m_fp=fopen(new_log,&quot;a&quot;); &#125; m_mutex.unlock(); va_list valst; va_start(valst,format); string log_str; m_mutex.lock(); int n=snprintf(m_buf,48,&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s&quot;, my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday, my_tm.tm_hour,my_tm.tm_min,my_tm.tm_sec,now.tv_usec,s); int m=vsnprintf(m_buf+n,m_log_buf_size-1,format,valst); m_buf[n+m]=&#x27;\\n&#x27;; m_buf[n+m+1]=&#x27;\\0&#x27;; log_str=m_buf; m_mutex.unlock(); if(m_is_asyns&amp;&amp;!m_log_queue-&gt;full()) m_log_queue-&gt;push(log_str); else &#123; m_mutex.lock(); fputs(log_str.c_str(),m_fp); m_mutex.unlock(); &#125; va_end(valst);&#125; level参数表示日志的分级，0——debug：调试代码的输出，在系统实际运行时，一般不使用；1——info：报告系统当前的状态，当前执行的流程或接收的信息；2——warn：这种警告与调试时终端的warning类似，同样是调试代码时使用；3——error：这种警告与调试时终端的warning类似，同样是调试代码时使用。日志写入前会判断当前day是否为创建日志的时间，行数是否超过最大行限制。若为创建日志时间，写入日志，否者按当前时间创建新log，更新创建时间和行数，若行数超过最大行限制，在当前日志的末尾加count&#x2F;max_lines为后缀创建新log。通过m_is_asyns标识判断异步&#x2F;同步日志，异步则将日志信息加入阻塞队列，同步则加锁向文件中写。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"日志系统","slug":"日志系统","permalink":"http://example.com/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"}]},{"title":"数据库连接池","slug":"数据库连接池","date":"2022-03-10T13:05:39.000Z","updated":"2022-05-29T06:22:44.246Z","comments":true,"path":"2022/03/10/数据库连接池/","link":"","permalink":"http://example.com/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"整体概述池是一种资源的容器，有多种实现方法，如数组、链表、队列等，本项目使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。数据库模块可以分为两部分，其一是数据库连接池的定义和初始化，其二是利用连接池完成登录和注册的校验功能。具体而言，工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还给连接池。","text":"整体概述池是一种资源的容器，有多种实现方法，如数组、链表、队列等，本项目使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。数据库模块可以分为两部分，其一是数据库连接池的定义和初始化，其二是利用连接池完成登录和注册的校验功能。具体而言，工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还给连接池。 基础知识数据库访问流程：当系统需要访问数据库时，首先创建数据库连接，完成数据库操作后，再断开数据库连接。数据库连接池：池是一组资源的集合，在服务器启动之初就被完全创建好并初始化。数据库连接池中的资源就是一组数据库连接，由系统动态地对池中的连接进行使用和释放。当系统开始处理客户请求时，如果它需要相关的资源，可以直接从池中获取，无需动态分配。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。连接池的必要性：如果系统需要频繁访问数据库，则需要频繁创建和断开数据库连接，而这是一个很消耗资源的操作，也容易对数据库造成安全隐患。如果在程序初始化的时候，集中创建多个数据库连接，并把它们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。 基础APImysql_init函数1MYSQL* mysql_init(MYSQL *mysql) 作用：分配或初始化与mysql_real_connect()相适应的MYSQL对象，如果mysql_init()分配了新的对象，应当在程序中调用mysql_close()来关闭连接，以释放对象； 参数：如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址； 返回值：初始化的MYSQL*句柄，如果无足够内存以分配新的对象，返回NULL错误，在内存不足的情况下，返回NULL； mysql_close函数1void mysql_close(MYSQL *mysql) 关闭前面打开的连接，如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄。 mysql_real_connect函数12MYSQL* mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 作用：连接数据库引擎，尝试与运行在主机上的MySQL数据库引擎建立连接； 参数： mysql：MYSQL变量； host：MYSQL服务器的地址，如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接； user：登录用户名，如果“user”是NULL或空字符串””，用户将被视为当前用户； passwd：登录密码； db：要连接的数据库，如果db为NULL，连接会将默认的数据库设为该值； port：MYSQL服务器的TCP服务端口； unix_socket：unix连接方式，如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道； clientflag：Mysql运行为ODBC数据库的标记，一般取0； 返回值：如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。 mysql_query函数1int mysql_query(MYSQL *mysql, const char *query) 作用：查询数据库中的某一个表内容； 参数： mysql：MYSQL变量； query：由“Null终结的字符串”查询指向的SQL查询，正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号（‘;’）或“\\g”，如果允许多语句执行，字符串可包含多条由分号隔开的语句。mysql_query()不能用于包含二进制数据的查询，应使用mysql_real_query()取而代之（二进制数据可能包含字符‘\\0’，mysql_query()会将该字符解释为查询字符串结束），如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查。 返回值：如果查询成功，返回0。如果出现错误，返回非0值； 1int mysql_real_query(MYSQL *mysql, const char *q, unsigned long length) 作用：查询数据库中的某一个表内容； 参数： mysql：MYSQL变量； q：SQL查询语句； length：查询语句的长度； 返回值：如果查询成功，返回0。如果出现错误，返回非0值； mysql_store_result函数1MYSQL_RES* mysql_store_result(MYSQL *mysql) 作用：显示查询数据库中数据表的内容； 说明： 对于成功检索了数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK TABLE等），必须调用mysql_store_result()或mysql_use_result()； 如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查； 如果查询未返回结果集，mysql_store_result()将返回Null指针（例如，如果查询是INSERT语句）； 如果读取结果集失败，mysql_store_result()还会返回Null指针； 一旦调用了mysql_store_result()并获得了不是Null指针的结果，可调用mysql_num_rows()来找出结果集中的行数； 可以调用mysql_fetch_row()来获取结果集中的行，或调用mysql_row_seek()和mysql_row_tell()来获取或设置结果集中的当前行位置； 一旦完成了对结果集的操作，必须调用mysql_free_result()； 返回值：具有多个结果的MYSQL_RES结果集合，如果出现错误，返回NULL； mysql_fetch_row函数1MYSQL_ROW mysql_fetch_row(MYSQL_RES* result) 作用：从结果集中获取下一行； 说明： 在mysql_store_result()之后使用时，如果没有要检索的行，mysql_fetch_row()返回NULL； 在mysql_use_result()之后使用时，如果没有要检索的行或出现了错误，mysql_fetch_row()返回NULL； 行内值的数目由mysql_num_fields(result)给出。如果行中保存了调用mysql_fetch_row()返回的值，将按照row[0]到row[mysql_num_fields(result)-1]，访问这些值的指针； 可以通过调用mysql_fetch_lengths()来获得行中字段值的长度。对于空字段以及包含NULL的字段，长度为0。通过检查字段值的指针，能够区分它们。如果指针为NULL，字段为NULL，否则字段为空； 返回值：下一行的MYSQL_ROW结构。如果没有更多要检索的行或出现了错误，返回NULL； mysql_field_count函数1unsigned int mysql_field_count(MYSQL *mysql) 作用：返回作用在连接上的最近查询的列数； 说明：该函数的正常使用是在mysql_store_result()返回NULL（因而没有结果集指针）时。在这种情况下，可调用mysql_field_count()来判定mysql_store_result()是否应生成非空结果。这样，客户端就能采取恰当的动作，而无需知道查询是否是SELECT（或类似SELECT的）语句； 返回值：表示结果集中列数的无符号整数； 核心代码分析成员变量123456789101112string m_url; //主机地址string m_Port; //数据库端口号string m_User; //登录数据库用户名string m_Password; //登录数据库密码string m_Databasename; //使用数据库名int m_close_log; //日志开关locker lock;list&lt;MYSQL*&gt; connList; //连接池sem reserve;int m_MaxConn; //最大连接数int m_CurConn; //当前已使用的连接数int m_FreeConn; //当前空闲的连接数 RAII机制创建、释放资源123456connectionRAII::connectionRAII(MYSQL** SQL,connection_poll* connpool)&#123; *SQL=connpool-&gt;GetConnection(); conRAII=*SQL; poolRAII=connpool;&#125; 将数据库连接的获取与释放通过RAII机制封装，避免手动释放。 单例模式创建类对象12345connection_poll* connection_poll::GetInstance()&#123; static connection_poll connPool; return &amp;connPool;&#125; 通过单例模式创建数据库连接池，返回静态成员变量。 初始化数据库连接池123456789101112131415161718192021222324252627282930void connection_poll::init(string url,string User,string Password,string Databasename,int Port,int Maxconn,int close_log)&#123; m_url=url; m_Port=Port; m_User=User; m_Password=Password; m_Databasename=Databasename; m_close_log=close_log; for(int i=0;i&lt;Maxconn;i++) &#123; MYSQL* con=NULL; con=mysql_init(con); if(con==NULL) &#123; LOG_ERROR(&quot;MySQL Error&quot;); exit(1); &#125; con=mysql_real_connect(con,url.c_str(),User.c_str(),Password.c_str(),Databasename.c_str(),Port,NULL,0); if(con==NULL) &#123; LOG_ERROR(&quot;MySQL Error&quot;); exit(1); &#125; connList.push_back(con); m_FreeConn++; &#125; reserve=sem(m_FreeConn); m_MaxConn=m_FreeConn;&#125; 创建Maxconn个数据库连接。 返回数据库连接1234567891011121314MYSQL* connection_poll::GetConnection()&#123; MYSQL* con=NULL; if(connList.size()==0) return NULL; reserve.wait(); lock.lock(); con=connList.front(); connList.pop_front(); m_FreeConn--; m_CurConn++; lock.unlock(); return con;&#125; 当有请求时，从数据库连接池中返回一个可用连接，原子-1，更新使用和空闲连接数，若连接池内没有连接了，则阻塞等待。 释放数据库连接123456789101112bool connection_poll::ReleaseConnection(MYSQL* con)&#123; if(con==NULL) return false; lock.lock(); connList.push_back(con); m_FreeConn++; m_CurConn--; lock.unlock(); reserve.post(); return true;&#125; 释放连接，原子+1。 销毁数据库连接池1234567891011121314151617void connection_poll::DestroyPool()&#123; lock.lock(); if(connList.size()&gt;0) &#123; list&lt;MYSQL*&gt;::iterator it; for(it=connList.begin();it!=connList.end();it++) &#123; MYSQL* con=*it; mysql_close(con); &#125; m_CurConn=0; m_FreeConn=0; connList.clear(); &#125; lock.unlock();&#125; 通过迭代器遍历数据库连接池链表，关闭对应数据库连接，清空链表并重置空闲连接和现有连接数量。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"数据库连接池","slug":"数据库连接池","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}]},{"title":"线程池","slug":"线程池","date":"2022-03-05T07:54:01.000Z","updated":"2022-05-29T06:22:47.974Z","comments":true,"path":"2022/03/05/线程池/","link":"","permalink":"http://example.com/2022/03/05/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"整体概述线程池是一种基于池化思想管理和使用线程的机制。它是将多个线程预先存储在一个“池子”内，当有任务出现时可以避免重新创建和销毁线程所带来性能开销，只需要从“池子”内取出相应的线程执行对应的任务即可。当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。","text":"整体概述线程池是一种基于池化思想管理和使用线程的机制。它是将多个线程预先存储在一个“池子”内，当有任务出现时可以避免重新创建和销毁线程所带来性能开销，只需要从“池子”内取出相应的线程执行对应的任务即可。当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。 基础知识IOIO的英文全称是Input&#x2F;Output，就是输入&#x2F;输出。应用程序发起的一次IO操作包含两个阶段：IO调用——应用程序进程向操作系统内核发起调用，IO执行——操作系统内核完成IO操作。操作系统内核完成IO操作还包括两个阶段：准备数据——内核等待I&#x2F;O设备准备好数据，拷贝数据——将数据从内核缓冲区拷贝到用户进程缓冲区。其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、Socket通讯的网卡。一个完整的IO过程包括以下几个步骤： 应用程序进程向操作系统发起IO调用请求 操作系统准备数据，把IO外部设备的数据，加载到内核区 操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区 IO模型阻塞IO模型：应用程序的进程发起IO调用，如果内核的数据还没准备好的话，那应用程序就一直在阻塞等待，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示。非阻塞IO模型：应用程序的进程发起IO调用，如果内核的数据还没准备好的话，就返回错误信息给用户进程，让其不需要等待，而是通过轮询的方式再来请求，其基本流程如下： 应用进程向操作系统内核发起读数据请求 操作系统内核数据未准备好，立刻返回错误码 应用程序进程轮询调用，继续向操作系统内核发起读数据请求 操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间 完成调用，返回成功提示 IO多路复用模型：系统提供一类函数（select、poll、epoll），它们可以同时监控多个fd文件描述符，任何一个返回内核数据就绪，应用进程再发起系统调用。 select poll epoll 底层数据结构 数组 链表 红黑树和链表 获取就绪的fd 遍历 遍历 事件回调 事件复杂度 O(n) O(n) O(1) 最大连接数 1024 无限制 无限制 fd数据拷贝 每次调用select，需要将fd数据从用户空间拷贝到内核空间 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 使用内存映射，不需要从用户空间频繁拷贝fd数据到内核空间 信号驱动IO模型：不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号，然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过信号通知应用进程数据准备好后的可读状态，应用用户进程收到信号之后，立刻调用读写操作。异步IO模型：前面提到的阻塞、非阻塞、信号驱动、多路复用IO模型，在数据从内核复制到应用缓冲区的时候，都是阻塞的，因此都不算是真正的异步。而异步IO可以实现IO全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是立即返回的不是处理结果，而是表示类似提交成功的意思。等内核数据准备好，将数据拷贝到用户缓冲区，发送信号通知用户进程IO操作执行完毕。 事件处理模型服务器程序通常需要处理三类事件：I&#x2F;O 事件、信号及定时事件。随着网络设计模式的兴起，Reactor和Proactor事件处理模式应运而生。同步IO模型通常用于实现Reactor模式，异步IO模型则用于实现Proactor模式。Reactor模式：Reactor模式要求主线程（I&#x2F;O 处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。使用同步I&#x2F;O模型（以epoll_wait为例）实现的Reactor模式的工作流程是： 主线程往epoll内核事件表中注册socket上的读就绪事件。 主线程调用epoll_wait等待socket上有数据可读。 当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 主线程调用epoll_wait等待socket可写。 当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作进程被唤醒，它往socket上写入服务器处理客户请求的结果。 Proactor模式：与Reactor模式不同，Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理,工作线程仅仅负责业务逻辑。使用异步I&#x2F;O模型（以aio_read和aio_write为例）实现的Proactor 模式的工作流程是： 主线程调用aio_read函数向内核注册socket上的读完成事件,并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。 主线程继续处理其他逻辑。 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例） 主线程继续处理其他逻辑 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 同步IO模拟Proactor模式由于异步I&#x2F;O并不成熟，实际中使用较少，这里将使用同步I&#x2F;O模拟实现proactor模式。同步I&#x2F;O模型的工作流程如下（epoll_wait为例）： 主线程往epoll内核事件表注册socket上的读就绪事件。 主线程调用epoll_wait等待socket上有数据可读 当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 主线程调用epoll_wait等待socket可写。 当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。 基础API线程创建函数1int pthread_create(pthread_t *tidp, const pthread_attr_t *attr, (void*)(*start_rtn)(void*), void *arg); 作用：创建新线程； 参数： tidp：指向线程标识符的指针； attr：设置线程属性； start_rtn：线程运行函数的起始地址； arg：运行函数的参数； 返回值：若线程创建成功，则返回0。若线程创建失败，则返回出错编号； 线程分离函数1int pthread_detach(pthread_t thread); 作用：实现线程分离，不再受主线程管理，由系统接任，线程结束后，其退出状态不由其它线程获取，而由自己自动释放。 参数： thread：线程id； 返回值：调用成功返回0，失败返回出错编号； 核心代码分析成员变量12345678int m_thread_number; //线程池中的线程数int m_max_requests; //请求队列中允许的最大请求数pthread_t *m_threads; //描述线程池的数组，其大小为m_thread_numberstd::list&lt;T *&gt; m_workqueue; //请求队列locker m_queuelocker; //保护请求队列的互斥锁sem m_queuestat; //是否有任务需要处理connection_poll *m_connPool; //数据库int m_actor_model; //模型切换 构造函数12345678910111213141516171819202122template &lt;typename T&gt;threadpool&lt;T&gt;::threadpool( int actor_model, connection_poll *connPool, int thread_number, int max_requests) : m_actor_model(actor_model),m_thread_number(thread_number), m_max_requests(max_requests), m_threads(NULL),m_connPool(connPool)&#123; if (thread_number &lt;= 0 || max_requests &lt;= 0) throw std::exception(); m_threads = new pthread_t[m_thread_number]; if (!m_threads) throw std::exception(); for (int i = 0; i &lt; thread_number; ++i) &#123; if (pthread_create(m_threads + i, NULL, worker, this) != 0) &#123; delete[] m_threads; throw std::exception(); &#125; if (pthread_detach(m_threads[i])) &#123; delete[] m_threads; throw std::exception(); &#125; &#125;&#125; 初始化线程池中的线程数、请求队列允许的最大请求数和模型切换标志。建立多个线程，执行work回调函数，同时对线程设置detach属性，此时线程执行完毕后自动回收进程。 公有线程工作函数123456void *threadpool&lt;T&gt;::worker(void *arg)&#123; threadpool *pool = (threadpool *)arg; pool-&gt;run(); return pool;&#125; 调用私有成员函数run。 私有线程工作函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template &lt;typename T&gt;void threadpool&lt;T&gt;::run()&#123; while (true) &#123; m_queuestat.wait(); m_queuelocker.lock(); if (m_workqueue.empty()) &#123; m_queuelocker.unlock(); continue; &#125; T *request = m_workqueue.front(); m_workqueue.pop_front(); m_queuelocker.unlock(); if (!request) continue; if (1 == m_actor_model) &#123; if (0 == request-&gt;m_state) &#123; if (request-&gt;read_once()) &#123; request-&gt;improv = 1; connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool); request-&gt;process(); &#125; else &#123; request-&gt;improv = 1; request-&gt;timer_flag = 1; &#125; &#125; else &#123; if (request-&gt;write()) &#123; request-&gt;improv = 1; &#125; else &#123; request-&gt;improv = 1; request-&gt;timer_flag = 1; &#125; &#125; &#125; else &#123; connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool); request-&gt;process(); &#125; &#125;&#125; m_actor_model为模型切换标志，0表示proactor模式，1表示reactor模式。m_state为读写标志，0为读，1为写。在读状态下时，如果一次性读函数成功，将improv标志置1，从数据库池中取出一个数据库连接，之后执行处理读取http请求函数，如果一次性读函数失败，将timer_flag标志置1，后续从定时器队列中删除此定时器。在写状态下，执行返回http响应函数，如果失败，同样置timer_flag标志为1。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"线程池","slug":"线程池","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"自封装锁","slug":"自封装锁","date":"2022-03-02T02:31:27.000Z","updated":"2022-05-29T06:35:30.045Z","comments":true,"path":"2022/03/02/自封装锁/","link":"","permalink":"http://example.com/2022/03/02/%E8%87%AA%E5%B0%81%E8%A3%85%E9%94%81/","excerpt":"整体概述对Linux下三种锁（信号量、互斥锁、条件变量）进行封装，将锁的创建和销毁函数封装在类的构造和析构函数中，实现RAII机制。","text":"整体概述对Linux下三种锁（信号量、互斥锁、条件变量）进行封装，将锁的创建和销毁函数封装在类的构造和析构函数中，实现RAII机制。 基础知识信号量信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V)，假设有信号量SV，P操作：如果SV的值大于0，则将其减一，若SV的值为0，则挂起执行；V操作：如果有其他进行因为等待SV而挂起，则唤醒，若没有，则将SV值加一。 互斥锁互斥锁，也成互斥量，可以保护关键代码段，以确保独占式访问，当进入关键代码段，获得互斥锁将其加锁，离开关键代码段，唤醒等待该互斥锁的线程。 条件变量条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。 RAIIRAII是Resource Acquisition Is Initialization的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤： 申请资源； 使用资源； 释放资源； 第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。但是如果程序很复杂的时候，需要为所有的new分配的内存delete掉，导致极度臃肿，效率下降，更可怕的是，程序的可理解性和可维护性明显降低了，当操作增多时，处理资源释放的代码就会越来越多，越来越乱。如果某一个操作发生了异常而导致释放资源的语句没有被调用，这个时候RAII机制就可以派上用场了。 基础API信号量初始化1int sem_init(sem_t* sem,int pshared,unsigned int value); 作用：初始化信号量； 参数： sem：指向未初始化信号量结构的一个指针； pshared：表示这个信号量是在进程的线程之间共享，还是在进程之间共享； 如果为0，那么这个信号量会在进程的线程之间共享，并且应该位于对所有线程都可见的某个地址； 如果不为0，那么这个信号量将在进程之间共享，并且应该位于共享内存的某个区域； value：指定信号量的初始值； 返回值：成功返回0，失败返回-1； 信号量销毁1int sem_destroy(sem_t *sem); 作用：释放信号量； 参数： sem：通过sem_init()初始化的信号量； 返回值：成功返回0，失败返回-1； 信号量原子-11int sem_wait(sem_t *sem); 作用：是一个原子操作，它的作用是将信号量的值-1，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait(),线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会地等待直到有其它线程增加了这个值使它不再是0为止； 参数： sem：通过sem_init()初始化的信号量； 返回值：成功返回0，失败返回-1； 信号量原子+11int sem_post(sem_t *sem); 作用：给信号量的值+1，它是一个原子操作，即同时对同一个信号量做+1操作的两个线程是不会冲突的； 参数： sem：通过sem_init()初始化的信号量； 返回值：成功返回0，失败返回-1； 互斥锁初始化1int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr); 作用：初始化互斥锁； 参数： mutex：初始化互斥锁的地址； attr：指定了新建互斥锁的属性，如果参数attr为NULL，则使用默认的互斥锁属性； 返回值：调用成功返回0，否则返回一个非0的错误代码； 互斥锁销毁1int pthread_mutex_destroy(pthread_mutex_t *mutex); 作用：释放分配给互斥锁mutex的资源； 参数： mutex：需要销毁的互斥锁地址； 返回值：调用成功返回0，否则返回一个非0的错误代码； 互斥锁上锁1int pthread_mutex_lock(pthread_mutex_t *mutex); 作用：锁住互斥锁变量，如果已被锁住，那么发出调用的线程将被阻塞直到其它进程对mutex解锁； 参数： mutex：需要上锁的互斥锁地址； 返回值：上锁成功返回0，否则返回一个非0的错误代码； 互斥锁解锁1int pthread_mutex_unlock(pthread_mutex_t *mutex); 作用：解除互斥锁，释放mutex引用的互斥锁对象，如果调用pthread_mutex_unlock()时有多个线程被mutex对象阻塞，则互斥锁变为可用时调度策略可确定获取该互斥锁的线程。 参数： mutex：需要解锁的互斥锁地址； 返回值：解锁成功返回0，否则返回一个非0的错误代码； 信号量初始化1int pthread_cond_init(pthread_cond_t *cond,const pthread_condattr_t *attr); 作用：初始化一个条件变量； 参数： cond：需要初始化的条件变量地址； attr：需要指定的条件变量的属性，默认为0； 返回值：初始化成功返回0，否则返回一个非0的错误代码； 信号量销毁1int pthread_cond_destroy(pthread_cond_t *cond); 作用：销毁一个条件变量，释放资源； 参数： cond：需要销毁的条件变量地址； 返回值：销毁成功返回0，否则返回一个非0的错误代码； 信号量wait12int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);int pthread_cond_timedwait(pthread_cond_t *cond,pthread_mutex_t *mutex, const structtimespec * abstime); 作用：线程阻塞在条件变量，直到收到这个条件变量相关的通知。需要传入已经lock的mutex变量。进入wait函数会自动解锁mutex参数指向的互斥锁，并使当前线程阻塞在cond参数指向的条件变量上。当线程被唤醒，退出wait函数时会自动对锁再次进行加锁，成功后返回。被阻塞的线程可以被pthread_cond_signal函数、pthread_cond_broadcast函数唤醒。一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。 参数： cond：条件变量地址； mutex：互斥锁地址； abstime：指定超时时间，函数到了一定的时间，即使条件未发生也会解除阻塞； 返回值：调用成功返回0，否则返回一个非0的错误代码； 信号量signal12int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond); 作用：这两个函数都会对指定的条件变量产生信号，通知其他线程。唯一一个区别在于当有多个线程阻塞等待条件变量的信号时，这两个函数产生信号后，对其他线程产生的影响会不一样。pthread_cond_signal 会保证至少会唤醒其中一个阻塞在这个条件变量的的线程。pthread_cond_broadcast会唤醒所有阻塞在这个条件变量的线程，适用于那些阻塞的不同线程被唤醒后会处理不同的任务。 参数：cond：条件变量地址； 返回值：调用成功返回0，否者返回一个非0的错误代码； 核心代码分析信号量类具体实现12345678910111213141516171819202122232425262728class sem&#123;private: sem_t m_sem;public: sem() &#123; if(sem_init(&amp;m_sem,0,0)!=0) throw std::exception(); &#125; sem(int num) &#123; if(sem_init(&amp;m_sem,0,num)!=0) throw std::exception(); &#125; ~sem() &#123; sem_destroy(&amp;m_sem); &#125; bool wait() &#123; return sem_wait(&amp;m_sem)==0; &#125; bool post() &#123; return sem_post(&amp;m_sem)==0; &#125;&#125;; 互斥锁类具体实现123456789101112131415161718192021222324252627class locker&#123;private: pthread_mutex_t m_mutex;public: locker() &#123; if(pthread_mutex_init(&amp;m_mutex,NULL)!=0) throw std::exception(); &#125; ~locker() &#123; pthread_mutex_destroy(&amp;m_mutex); &#125; bool lock() &#123; return pthread_mutex_lock(&amp;m_mutex)==0; &#125; bool unlock() &#123; return pthread_mutex_unlock(&amp;m_mutex)==0; &#125; pthread_mutex_t* get() &#123; return &amp;m_mutex; &#125;&#125;; 条件变量类具体实现123456789101112131415161718192021222324252627282930313233class cond&#123;private: pthread_cond_t m_cond;public: cond() &#123; if(pthread_cond_init(&amp;m_cond,NULL)!=0) throw std::exception(); &#125; ~cond() &#123; pthread_cond_destroy(&amp;m_cond); &#125; bool wait(pthread_mutex_t* m_mutex) &#123; int ret=pthread_cond_wait(&amp;m_cond,m_mutex); return ret==0; &#125; bool timewait(pthread_mutex_t* m_mutex,struct timespec t) &#123; int ret=pthread_cond_timedwait(&amp;m_cond,m_mutex,&amp;t); return ret==0; &#125; bool signal() &#123; return pthread_cond_signal(&amp;m_cond)==0; &#125; bool broadcast() &#123; return pthread_cond_broadcast(&amp;m_cond)==0; &#125;&#125;;","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"自封装锁","slug":"自封装锁","permalink":"http://example.com/tags/%E8%87%AA%E5%B0%81%E8%A3%85%E9%94%81/"}]},{"title":"main主函数","slug":"main主函数","date":"2022-03-01T10:01:21.000Z","updated":"2022-05-29T06:22:59.735Z","comments":true,"path":"2022/03/01/main主函数/","link":"","permalink":"http://example.com/2022/03/01/main%E4%B8%BB%E5%87%BD%E6%95%B0/","excerpt":"整体概述使用C++语言在Linux环境下搭建轻量级Web服务器，属于网络编程的简单实现，实现了以下功能： 结合线程池、socket套接字、epoll函数实现多线程的并发模型，通过标志位切换LT&#x2F;ET模式、Reactor&#x2F;模拟Proactor模式 结合主状态机、从状态机解析HTTP请求报文，可以处理GET和POST请求，返回服务器图片、视频资源 使用服务器内部数据库保存用户名、登录密码，实现用户通过浏览器进行注册、登录功能 基于有序链表实现定时器，关闭超时的非活跃连接 结合单例模式和阻塞队列实现异步写日志模式，记录服务器的运行状态","text":"整体概述使用C++语言在Linux环境下搭建轻量级Web服务器，属于网络编程的简单实现，实现了以下功能： 结合线程池、socket套接字、epoll函数实现多线程的并发模型，通过标志位切换LT&#x2F;ET模式、Reactor&#x2F;模拟Proactor模式 结合主状态机、从状态机解析HTTP请求报文，可以处理GET和POST请求，返回服务器图片、视频资源 使用服务器内部数据库保存用户名、登录密码，实现用户通过浏览器进行注册、登录功能 基于有序链表实现定时器，关闭超时的非活跃连接 结合单例模式和阻塞队列实现异步写日志模式，记录服务器的运行状态 基础知识Web服务器Web服务器是指驻留于因特网上某种类型计算机的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。服务器使用HTTP（超文本传输协议）与客户机浏览器进行信息交流，因此也常被称为HTTP服务器。 核心代码分析新建WebServer类对象1WebServer server; 新建WebServer类，通过构造函数初始化以下变量： 123456789101112m_port = 9006; //端口号，默认9006m_sql_num = 8; //数据库连接池数量，默认8m_thread_num = 8; //线程池内的线程数量，默认8m_log_write = 0; //写日志模式，默认为同步m_OPT_LINGER = 0; //优雅关闭连接，默认不使用m_LISTENTrigmode=0; //listenfd触发模式，默认LTm_CONNTrigmode=0; //connfd触发模式，默认LTm_close_log = 0; //关闭日志，默认不关闭m_actormodel = 0; //并发模型，默认是proactorm_user = &quot;root&quot;; //数据库信息:登录名m_passWord = &quot;1&quot;; //数据库信息:密码m_databaseName = &quot;yourdb&quot;; //数据库信息:库名 开启日志1server.log_write(); 调用Log类的init初始化函数。 建立数据库连接池1server.sql_pool(); 调用conection_poll类的init初始化函数，并调用数据库的initmysql_result函数，取得用户名、密码。 建立线程池1server.thread_pool(); 在线程池中新建指定数量的线程。 建立epoll监听套接字1server.eventListen(); 建立socket套接字，调用epoll函数监听。 处理epoll响应事件1server.eventLoop(); 处理epoll函数返回的响应事件集合。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]}],"categories":[{"name":"分布式缓存","slug":"分布式缓存","permalink":"http://example.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"},{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"master","slug":"master","permalink":"http://example.com/tags/master/"},{"name":"client","slug":"client","permalink":"http://example.com/tags/client/"},{"name":"cache","slug":"cache","permalink":"http://example.com/tags/cache/"},{"name":"心跳包","slug":"心跳包","permalink":"http://example.com/tags/%E5%BF%83%E8%B7%B3%E5%8C%85/"},{"name":"数据读写","slug":"数据读写","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99/"},{"name":"一致性哈希","slug":"一致性哈希","permalink":"http://example.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"},{"name":"通信格式","slug":"通信格式","permalink":"http://example.com/tags/%E9%80%9A%E4%BF%A1%E6%A0%BC%E5%BC%8F/"},{"name":"辅助函数","slug":"辅助函数","permalink":"http://example.com/tags/%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"},{"name":"LRU","slug":"LRU","permalink":"http://example.com/tags/LRU/"},{"name":"WebServer类","slug":"WebServer类","permalink":"http://example.com/tags/WebServer%E7%B1%BB/"},{"name":"http处理类","slug":"http处理类","permalink":"http://example.com/tags/http%E5%A4%84%E7%90%86%E7%B1%BB/"},{"name":"定时器","slug":"定时器","permalink":"http://example.com/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"name":"日志系统","slug":"日志系统","permalink":"http://example.com/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"},{"name":"数据库连接池","slug":"数据库连接池","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"name":"线程池","slug":"线程池","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"自封装锁","slug":"自封装锁","permalink":"http://example.com/tags/%E8%87%AA%E5%B0%81%E8%A3%85%E9%94%81/"}]}