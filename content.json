{"meta":{"title":"Hexo","subtitle":"","description":"study","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"文章分类","date":"2022-04-28T09:17:24.000Z","updated":"2022-04-28T10:36:35.287Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-28T09:15:08.000Z","updated":"2022-04-28T10:35:54.346Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"日志系统（上）","slug":"日志（上）","date":"2022-04-28T10:37:24.000Z","updated":"2022-05-03T05:24:06.207Z","comments":true,"path":"2022/04/28/日志（上）/","link":"","permalink":"http://example.com/2022/04/28/%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"日志系统（上）基础知识同步日志：写入日志操作和工作线程串行执行，当单条日志较大时，同步模式会降低服务器所能处理的并发能力异步日志: 先将需要写入的日志内容存入阻塞队列，写线程从阻塞队列中取出内容，写入日志生产者-消费者：生产者线程与消费者线程共享一个缓冲区，生产者往缓冲区中push消息，消费者从缓冲区中pop消息阻塞队列：封装生产者-消费者模型，把循环数组实现的队列作为缓冲区单例模式：一个类只创建一个实例，同时提供全局访问的方法。本项目使用单例模式创建日志类，避免在多线程环境下，多个线程同时分别执行写日志操作，造成日志信息互相覆盖的情况。 单例模式实现思路：私有化构造函数，防止外界创建类的对象，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例懒汉模式：在第一次被使用时才进行初始化 123456789101112class single&#123;private: single()&#123;&#125; ~single()&#123;&#125;public: static single* getinstance();&#125;;single* single::getinstance()&#123;static single obj;return &amp;obj;&#125; 饿汉模式：在程序运行时就定义了对象，并对其初始化 12345678910111213class single&#123;private: static single* p; single()&#123;&#125; ~single()&#123;&#125;public: static single* getinstance();&#125;;single* single::p = new single();single* single::getinstance()&#123;return p;&#125; 阻塞队列阻塞队列类中封装了生产者-消费者模型，其中push成员是生产者，pop成员是消费者，当队列为空时，从队列中获取元素的线程将会被挂起，当队列是满时，往队列里添加元素的线程将会挂起###成员变量 1234567locker m_mutex; //互斥锁cond m_cond; //条件变量T* m_array; //阻塞队列int m_size; //队列内的数量int m_max_size; //队列最大容量int m_front; //队列头int m_back; //队列尾 初始化、清除、析构12345678910111213141516171819202122232425block_queue(int max_size=1000)&#123; if(max_size&lt;=0) exit(-1); m_max_size=max_size; m_array=new T[max_size]; m_size=0; m_front=-1; m_back=-1;&#125;void clear()&#123; m_mutex.lock(); m_size=0; m_front=-1; m_back=-1; m_mutex.unlock();&#125;~block_queue()&#123; m_mutex.lock(); if(m_array!=NULL) delete[] m_array; m_mutex.unlock();&#125; 判断队列是否满、空12345678910111213141516171819202122bool full()&#123; m_mutex.lock(); if(m_size&gt;=m_max_size) &#123; m_mutex.unlock(); return true; &#125; m_mutex.unlock(); return false;&#125;bool empty()&#123; m_mutex.lock(); if(0==m_size) &#123; m_mutex.unlock(); return true; &#125; m_mutex.unlock(); return false;&#125; 返回队首元素、队尾元素、大小、最大值12345678910111213141516171819202122232425262728293031323334353637383940bool front(T&amp; value)&#123; m_mutex.lock(); if(m_size==0) &#123; m_mutex.unlock(); return false; &#125; value=m_array[m_front]; m_mutex.unlock(); return true;&#125;bool back(T&amp; value)&#123; m_mutex.lock(); if(m_size==0) &#123; m_mutex.unlock(); return false; &#125; value=m_array[m_back]; m_mutex.unlock(); return true;&#125;int size()&#123; int temp=0; m_mutex.lock(); temp=m_size; m_mutex.unlock(); return temp;&#125;int max_size()&#123; int temp=0; m_mutex.lock(); temp=m_max_size; m_mutex.unlock(); return temp;&#125; 往队列中添加、删除元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960bool push(const T&amp; item)&#123; m_mutex.lock(); if(m_size&gt;=m_max_size) &#123; m_cond.broadcast(); m_mutex.unlock(); return false; &#125; m_back=(m_back+1)%m_max_size; m_array[m_back]=item; m_size++; m_cond.broadcast(); m_mutex.unlock(); return true;&#125;bool pop(T&amp; item)&#123; m_mutex.lock(); while(m_size&lt;=0) &#123; if(m_cond.wait(m_mutex.get())) &#123; m_mutex.unlock(); return false; &#125; &#125; m_front=(m_front+1)%m_max_size; item=m_array[m_front]; m_size--; m_mutex.unlock(); return true;&#125;bool pop(T&amp; item,int ms_timeout)&#123; struct timespec t=&#123;0,0&#125;; struct timeval now=&#123;0,0&#125;; gettimeofday(&amp;now,NULL); m_mutex.lock(); if(m_size&lt;=0) &#123; t.tv_sec=now.tv_sec+ms_timeout/1000; t.tv_nsec=(ms_timeout%1000)*1000; if(!m_cond.timewait(m_mutex.get(),t)) &#123; m_mutex.unlock(); return false; &#125; &#125; if(m_size&lt;=0) &#123; m_mutex.unlock(); return false; &#125; m_front=(m_front+1)%m_max_size; item=m_array[m_front]; m_size--; m_mutex.unlock(); return true; &#125; 往队列中添加元素，需要将所有使用队列的线程先唤醒，当有元素push进队列，相当于生产者生产了一个元素，若当前没有线程等待条件变量，则唤醒无意义。pop时，如果队列没有元素，将会等待条件变量，增加了超时处理，指定时间内能抢到互斥锁即可。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]},{"title":"日志系统（下）","slug":"日志（下）","date":"2022-04-28T10:37:24.000Z","updated":"2022-05-03T05:24:27.577Z","comments":true,"path":"2022/04/28/日志（下）/","link":"","permalink":"http://example.com/2022/04/28/%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"日志系统（下）流程图日志类的成员变量、函数成员变量123456789101112char dir_name[128]; //路径名char log_name[128]; //log文件名int m_split_line; //日志最大行数int m_log_buf_size; //日志缓冲区大小long long m_count; //日志行数记录int m_today; //按天分文件，记录当前时间是哪一天FILE* m_fp; //打开log的文件指针char* m_buf; //要输出的内容block_queue&lt;string&gt;* m_log_queue; //阻塞队列bool m_is_asyns; //是否同步标志位locker m_mutex; //同步类int m_close_log; //关闭日志 日志类对象的初始化123456789101112131415161718192021222324252627282930313233bool Log::init(const char* file_name,int close_log,int log_buf_size,int split_lines,int max_queue_size)&#123; if(max_queue_size&gt;=1) &#123; m_is_asyns=true; m_log_queue=new block_queue&lt;string&gt;(max_queue_size); pthread_t tid; pthread_create(&amp;tid,NULL,flush_log_thread,NULL); &#125; m_close_log=close_log; m_log_buf_size=log_buf_size; m_buf=new char[m_log_buf_size]; memset(m_buf,&#x27;\\0&#x27;,m_log_buf_size); m_split_line=split_lines; time_t t=time(NULL); struct tm* sys_tm=localtime(&amp;t); struct tm my_tm=*sys_tm; const char* p=strrchr(file_name,&#x27;/&#x27;); char log_full_name[256]=&#123;0&#125;; if(p==NULL) snprintf(log_full_name,255,&quot;%d_%02d_%02d_%s&quot;,my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday,file_name); else &#123; strcpy(log_name,p+1); strncpy(dir_name,file_name,p-file_name+1); snprintf(log_full_name,255,&quot;%s%d_%02d_%02d_%s&quot;,dir_name,my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday,log_name); &#125; m_today=my_tm.tm_mday; m_fp=fopen(log_full_name,&quot;a&quot;); if(m_fp==NULL) return false; return true;&#125; max_queue_size为阻塞队列的长度，如果不为0，表示使用异步日志模式，此时设置m_is_asyns标志为true，生成指定大小的阻塞队列，创建线程，调用flush_log_thread回调函数，表示创建线程异步写日志。如果为0，表示使用同步日志模式。同时初始化log文件名、日志最大行数、日志缓冲区大小。 异步日志公有方法1234static void* flush_log_thread(void* args)&#123; Log::get_instance()-&gt;async_write_log();&#125; 调用私有方法async_write_log。 异步日志私有方法12345678910void* async_write_log()&#123; string single_log; while(m_log_queue-&gt;pop(single_log)) &#123; m_mutex.lock(); fputs(single_log.c_str(),m_fp); m_mutex.unlock(); &#125;&#125; 从阻塞队列中取出一条日志内容，写入文件，当阻塞队列为空时，线程阻塞等待，直到有新日志插入，唤醒线程。 用于其它文件中使用的日志写宏定义1234#define LOG_DEBUG(format, ...) if(m_close_log==0) &#123;Log::get_instance()-&gt;write_log(0,format,##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_INFO(format, ...) if(m_close_log==0) &#123;Log::get_instance()-&gt;write_log(1,format,##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_WARN(format, ...) if(m_close_log==0) &#123;Log::get_instance()-&gt;write_log(2,format,##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;#define LOG_ERROR(format, ...) if(m_close_log==0) &#123;Log::get_instance()-&gt;write_log(3,format,##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125; 定义四个宏，用于在其它文件中进行日志写操作，其中m_close_log&#x3D;&#x3D;0表示日志未关闭，get_instance函数为通过单例模式实现的日志类对象，write_log函数为写日志的具体逻辑实现，flush函数为刷新写缓冲区。 单例模式的日志类对象实现函数12345static Log* get_instance()&#123; static Log instance; return &amp;instance;&#125; 日志写的逻辑实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void Log::write_log(int level,const char* format, ...)&#123; struct timeval now=&#123;0,0&#125;; gettimeofday(&amp;now,NULL); time_t t=now.tv_sec; struct tm* sys_tm=localtime(&amp;t); struct tm my_tm=*sys_tm; char s[16]=&#123;0&#125;; switch(level) &#123; case 0: strcpy(s,&quot;[debug]:&quot;); break; case 1: strcpy(s,&quot;[info]:&quot;); break; case 2: strcpy(s,&quot;[warn]:&quot;); break; case 3: strcpy(s,&quot;[erro]:&quot;); break; default: strcpy(s,&quot;[info]:&quot;); break; &#125; m_mutex.lock(); m_count++; if(m_today!=my_tm.tm_mday||m_count%m_split_line==0) &#123; char new_log[256]=&#123;0&#125;; fflush(m_fp); fclose(m_fp); char tail[16]=&#123;0&#125;; snprintf(tail,16,&quot;%d_%02d_%02d_&quot;,my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday); if(m_today!=my_tm.tm_mday) &#123; snprintf(new_log,255,&quot;%s%s%s&quot;,dir_name,tail,log_name); m_today=my_tm.tm_mday; m_count=0; &#125; else snprintf(new_log,255,&quot;%s%s%s.%lld&quot;,dir_name,tail,log_name,m_count/m_split_line); m_fp=fopen(new_log,&quot;a&quot;); &#125; m_mutex.unlock(); va_list valst; va_start(valst,format); string log_str; m_mutex.lock(); int n=snprintf(m_buf,48,&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s&quot;, my_tm.tm_year+1900,my_tm.tm_mon+1,my_tm.tm_mday, my_tm.tm_hour,my_tm.tm_min,my_tm.tm_sec,now.tv_usec,s); int m=vsnprintf(m_buf+n,m_log_buf_size-1,format,valst); m_buf[n+m]=&#x27;\\n&#x27;; m_buf[n+m+1]=&#x27;\\0&#x27;; log_str=m_buf; m_mutex.unlock(); if(m_is_asyns&amp;&amp;!m_log_queue-&gt;full()) m_log_queue-&gt;push(log_str); else &#123; m_mutex.lock(); fputs(log_str.c_str(),m_fp); m_mutex.unlock(); &#125; va_end(valst);&#125; level参数表示日志的分级，0——debug：调试代码的输出，在系统实际运行时，一般不使用；1——info：报告系统当前的状态，当前执行的流程或接收的信息；2——warn：这种警告与调试时终端的warning类似，同样是调试代码时使用；3——error：这种警告与调试时终端的warning类似，同样是调试代码时使用。日志写入前会判断当前day是否为创建日志的时间，行数是否超过最大行限制。若为创建日志时间，写入日志，否者按当前时间创建新log，更新创建时间和行数，若行数超过最大行限制，在当前日志的末尾加count&#x2F;max_lines为后缀创建新log。通过m_is_asyns标识判断异步&#x2F;同步日志，异步则将日志信息加入阻塞队列，同步则加锁向文件中写。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]},{"title":"WebServer类","slug":"WebServer类","date":"2022-04-28T10:37:24.000Z","updated":"2022-05-03T05:23:36.583Z","comments":true,"path":"2022/04/28/WebServer类/","link":"","permalink":"http://example.com/2022/04/28/WebServer%E7%B1%BB/","excerpt":"","text":"WebServer类类的成员变量数据库相关12345connection_poll* m_connpool; //数据库连接池string m_user; //数据库信息:登录名string m_passWord; //数据库信息:密码string m_databaseName; //数据库信息:库名int m_sql_num; //连接池数量 线程池相关12threadpool&lt;http_conn&gt;* m_pool; //线程池int m_thread_num; //线程数量 epoll函数相关123456epoll_event events[MAX_EVENT_NUMBER]; //epoll调用返回的事件集合int m_epollfd; //epoll文件描述符int m_listenfd; //监听文件描述符int m_OPT_LINGER; //优雅关闭连接int m_LISTENTrigmode; //listenfd触发模式int m_CONNTrigmode; //connfd触发模式 定时器相关12client_data* users_timer; //定时器资源Utils utils; //定时器对象 http解析相关1http_conn* users; //http解析对象 其它资源123456int m_port; //端口号char* m_root; //root资源路径int m_log_write; //异步日志int m_close_log; //关闭日志int m_actormodel; //工作模式int m_pipefd[2]; //管道 类的构造、析构函数构造函数1234567891011121314151617181920212223242526 WebServer::WebServer()&#123; //http_conn类对象，默认最大事件数65536 users = new http_conn[MAX_FD]; //root文件夹路径 m_root=getcwd(nullptr,256); assert(m_root); strncat(m_root,&quot;/root&quot;,6); //定时器，默认最大事件数65536 users_timer = new client_data[MAX_FD]; m_port = 9006; //端口号，默认9006 m_sql_num = 8; //数据库连接池数量，默认8 m_thread_num = 8; //线程池内的线程数量，默认8 m_log_write = 0; //日志模式，默认同步 m_OPT_LINGER = 0; //优雅关闭连接，默认不使用 m_LISTENTrigmode=0; //listenfd触发模式，默认LT m_CONNTrigmode=0; //connfd触发模式，默认LT m_close_log = 0; //关闭日志，默认不关闭 m_actormodel = 0; //并发模型，默认是proactor m_user = &quot;root&quot;; //数据库信息:登录名 m_passWord = &quot;1&quot;; //数据库信息:密码 m_databaseName = &quot;yourdb&quot;; //数据库信息:库名&#125; 析构函数12345678910 WebServer::~WebServer()&#123; close(m_epollfd); //关闭epoll文件描述符 close(m_listenfd); //关闭监听文件描述符 close(m_pipefd[1]); //关闭管道 close(m_pipefd[0]); delete[] users; //释放http解析资源 delete[] users_timer;//释放定时器资源 delete m_pool; //释放线程池资源&#125; 开启日志12345678910 void WebServer::log_write()&#123; if (0 == m_close_log) //日志未关闭 &#123; if (1 == m_log_write) Log::get_instance()-&gt;init(&quot;./ServerLog&quot;, m_close_log, 2000, 800000, 800); //异步 else Log::get_instance()-&gt;init(&quot;./ServerLog&quot;, m_close_log, 2000, 800000, 0); //同步 &#125;&#125;","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]},{"title":"自封装锁类","slug":"自封装锁类","date":"2022-04-28T10:37:24.000Z","updated":"2022-05-03T05:25:19.173Z","comments":true,"path":"2022/04/28/自封装锁类/","link":"","permalink":"http://example.com/2022/04/28/%E8%87%AA%E5%B0%81%E8%A3%85%E9%94%81%E7%B1%BB/","excerpt":"","text":"自封装锁类RAII什么是RAII？RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。为什么要使用RAII？上面说到RAII是用来管理资源、避免资源泄漏的方法。那么，用了这么久了，也写了这么多程序了，口头上经常会说资源，那么资源是如何定义的？在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤：1 申请资源；2 使用资源；3 释放资源。第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。但是如果程序很复杂的时候，需要为所有的new 分配的内存delete掉，导致极度臃肿，效率下降，更可怕的是，程序的可理解性和可维护性明显降低了，当操作增多时，处理资源释放的代码就会越来越多，越来越乱。如果某一个操作发生了异常而导致释放资源的语句没有被调用，怎么办？这个时候，RAII机制就可以派上用场了。##信号量类信号量是一种特殊的变量，访问具有原子性,用于解决进程或者线程间共享资源引发的同步问题。 基础API1int sem_init(sem_t* sem,int pshared,unsigned int value); 参数说明:a. sem为指向未初始化信号量结构的一个指针b. pshared参数表示这个信号量是在进程的线程之间共享，还是在进程之间共享。 如果pshared的值为0，那么这个信号量会在进程的线程之间共享，并且应该位于对所有线程都可见的某个地址 如果pshared非零，那么这个信号量将在进程之间共享，并且应该位于共享内存的某个区域。c. value指定信号量的初始值功能:初始化信号量返回值:成功返回0，失败返回-1 1int sem_destroy(sem_t *sem); 参数说明:sem为通过sem_init()初始化的信号量功能:释放信号量返回值:成功返回0，失败返回-1 1int sem_wait(sem_t *sem); 参数说明:sem为通过sem_init()初始化的信号量功能:sem_wait函数也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait(),线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会地等待直到有其它线程增加了这个值使它不再是0为止。返回值:成功返回0，失败返回-1 1int sem_post(sem_t *sem); 参数说明:sem为通过sem_init()初始化的信号量功能:sem_post函数的作用是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；返回值:成功返回0，失败返回-1###具体实现 12345678910111213141516171819202122232425262728 class sem&#123;private: sem_t m_sem;public: sem() &#123; if(sem_init(&amp;m_sem,0,0)!=0) throw std::exception(); &#125; sem(int num) &#123; if(sem_init(&amp;m_sem,0,num)!=0) throw std::exception(); &#125; ~sem() &#123; sem_destroy(&amp;m_sem); &#125; bool wait() &#123; return sem_wait(&amp;m_sem)==0; &#125; bool post() &#123; return sem_post(&amp;m_sem)==0; &#125;&#125;; 互斥锁类互斥锁是一种用于多线程编程中，防止两条线程同时对同一公共资源进行读写的机制。 基础API1int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr); 初始化互斥锁，参数attr指定了新建互斥锁的属性。如果参数attr为NULL，则使用默认的互斥锁属性。 1int pthread_mutex_destroy(pthread_mutex_t *mp); 销毁互斥锁 1int pthread_mutex_lock(pthread_mutex_t *mutex); 锁定互斥锁，当 pthread_mutex_lock() 返回时，该互斥锁已被锁定。调用线程是该互斥锁的属主。如果该互斥锁已被另一个线程锁定和拥有，则调用线程将阻塞，直到该互斥锁变为可用为止。 1int pthread_mutex_unlock(pthread_mutex_t *mutex); 解除互斥锁，释放mutex引用的互斥锁对象。如果调用 pthread_mutex_unlock() 时有多个线程被 mutex 对象阻塞，则互斥锁变为可用时调度策略可确定获取该互斥锁的线程。 具体实现123456789101112131415161718192021222324252627class locker&#123;private: pthread_mutex_t m_mutex;public: locker() &#123; if(pthread_mutex_init(&amp;m_mutex,NULL)!=0) throw std::exception(); &#125; ~locker() &#123; pthread_mutex_destroy(&amp;m_mutex); &#125; bool lock() &#123; return pthread_mutex_lock(&amp;m_mutex)==0; &#125; bool unlock() &#123; return pthread_mutex_unlock(&amp;m_mutex)==0; &#125; pthread_mutex_t* get() &#123; return &amp;m_mutex; &#125;&#125;; 条件变量类条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。 基础API1int pthread_cond_init(pthread_cond_t *cond,const pthread_condattr_t *attr); 初始化一个条件变量。当参数attr为空指针时，函数创建的是一个缺省的条件变量。返回值：函数成功返回0；任何其他返回值都表示错误 1int pthread_cond_destroy(pthread_cond_t *cond); 释放条件变量 1int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex); wait需要传入已经lock的mutex变量。进入wait函数会自动解锁mutex参数指向的互斥锁，并使当前线程阻塞在cond参数指向的条件变量上。当线程被唤醒，退出wait函数时会自动对锁再次进行加锁，成功后返回。被阻塞的线程可以被pthread_cond_signal函数，pthread_cond_broadcast函数唤醒。一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。 1int pthread_cond_timedwait(pthread_cond_t *cond,pthread_mutex_t *mutex, const structtimespec * abstime); 函数到了一定的时间，即使条件未发生也会解除阻塞。这个时间由参数abstime指定。 1int pthread_cond_signal(pthread_cond_t *cond); 函数被用来释放被阻塞在指定条件变量上的一个线程。唤醒阻塞在条件变量上的所有线程的顺序由调度策略决定，如果线程的调度策略是SCHED_OTHER类型的，系统将根据线程的优先级唤醒线程。 1int pthread_cond_broadcast(pthread_cond_t *cond); 函数唤醒所有被pthread_cond_wait函数阻塞在某个条件变量上的线程，参数cond被用来指定这个条件变量。###具体实现 123456789101112131415161718192021222324252627282930313233class cond&#123;private: pthread_cond_t m_cond;public: cond() &#123; if(pthread_cond_init(&amp;m_cond,NULL)!=0) throw std::exception(); &#125; ~cond() &#123; pthread_cond_destroy(&amp;m_cond); &#125; bool wait(pthread_mutex_t* m_mutex) &#123; int ret=pthread_cond_wait(&amp;m_cond,m_mutex); return ret==0; &#125; bool timewait(pthread_mutex_t* m_mutex,struct timespec t) &#123; int ret=pthread_cond_timedwait(&amp;m_cond,m_mutex,&amp;t); return ret==0; &#125; bool signal() &#123; return pthread_cond_signal(&amp;m_cond)==0; &#125; bool broadcast() &#123; return pthread_cond_broadcast(&amp;m_cond)==0; &#125;&#125;;","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]},{"title":"main主函数","slug":"main主函数","date":"2022-04-28T10:37:24.000Z","updated":"2022-05-03T05:22:42.139Z","comments":true,"path":"2022/04/28/main主函数/","link":"","permalink":"http://example.com/2022/04/28/main%E4%B8%BB%E5%87%BD%E6%95%B0/","excerpt":"","text":"webserver项目主函数123456789101112m_port = 9006; //端口号，默认9006m_sql_num = 8; //数据库连接池数量，默认8m_thread_num = 8; //线程池内的线程数量，默认8m_log_write = 0; //关闭日志，默认不关闭m_OPT_LINGER = 0; //优雅关闭连接，默认不使用m_LISTENTrigmode=0; //listenfd触发模式，默认LTm_CONNTrigmode=0; //connfd触发模式，默认LTm_close_log = 0; //关闭日志，默认不关闭m_actormodel = 0; //并发模型，默认是proactorm_user = &quot;root&quot;; //数据库信息:登录名m_passWord = &quot;1&quot;; //数据库信息:密码m_databaseName = &quot;yourdb&quot;; //数据库信息:库名 1WebServer server; 新建WebServer类，通过构造函数初始化变量 1server.log_write(); 开启日志 1server.sql_pool(); 建立数据库 1server.thread_pool(); 建立线程池 1server.eventListen(); 建立监听socket套接字 1server.eventLoop(); 循环监听连接","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-27T14:40:30.996Z","updated":"2022-04-27T14:40:30.996Z","comments":true,"path":"2022/04/27/hello-world/","link":"","permalink":"http://example.com/2022/04/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]}