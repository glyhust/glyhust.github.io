{"meta":{"title":"gly的学习博客","subtitle":"既是学习记录 又是技术分享","description":"learn","author":"gong luyang","url":"http://example.com","root":"/"},"pages":[{"title":"文章分类","date":"2022-04-28T09:17:24.000Z","updated":"2022-04-28T10:36:35.287Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-28T09:15:08.000Z","updated":"2022-04-28T10:35:54.346Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线程池","slug":"线程池","date":"2022-04-28T10:37:24.000Z","updated":"2022-05-06T14:13:26.727Z","comments":true,"path":"2022/04/28/线程池/","link":"","permalink":"http://example.com/2022/04/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"整体概述线程池是一种基于池化思想管理和使用线程的机制。它是将多个线程预先存储在一个“池子”内，当有任务出现时可以避免重新创建和销毁线程所带来性能开销，只需要从“池子”内取出相应的线程执行对应的任务即可。当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。","text":"整体概述线程池是一种基于池化思想管理和使用线程的机制。它是将多个线程预先存储在一个“池子”内，当有任务出现时可以避免重新创建和销毁线程所带来性能开销，只需要从“池子”内取出相应的线程执行对应的任务即可。当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。 基础知识IOIO的英文全称是Input&#x2F;Output，就是输入&#x2F;输出。应用程序发起的一次IO操作包含两个阶段：IO调用——应用程序进程向操作系统内核发起调用，IO执行——操作系统内核完成IO操作。操作系统内核完成IO操作还包括两个阶段：准备数据——内核等待I&#x2F;O设备准备好数据，拷贝数据——将数据从内核缓冲区拷贝到用户进程缓冲区。其实IO就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、Socket通讯的网卡。一个完整的IO过程包括以下几个步骤： 应用程序进程向操作系统发起IO调用请求 操作系统准备数据，把IO外部设备的数据，加载到内核区 操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区 IO模型阻塞IO模型：应用程序的进程发起IO调用，如果内核的数据还没准备好的话，那应用程序就一直在阻塞等待，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示。非阻塞IO模型：应用程序的进程发起IO调用，如果内核的数据还没准备好的话，就返回错误信息给用户进程，让其不需要等待，而是通过轮询的方式再来请求，其基本流程如下： 应用进程向操作系统内核发起读数据请求 操作系统内核数据未准备好，立刻返回错误码 应用程序进程轮询调用，继续向操作系统内核发起读数据请求 操作系统内核数据准备好了，从内核缓冲区拷贝到用户空间 完成调用，返回成功提示 IO多路复用模型：系统提供一类函数（select、poll、epoll），它们可以同时监控多个fd文件描述符，任何一个返回内核数据就绪，应用进程再发起系统调用。 select poll epoll 底层数据结构 数组 链表 红黑树和链表 获取就绪的fd 遍历 遍历 事件回调 事件复杂度 O(n) O(n) O(1) 最大连接数 1024 无限制 无限制 fd数据拷贝 每次调用select，需要将fd数据从用户空间拷贝到内核空间 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 使用内存映射，不需要从用户空间频繁拷贝fd数据到内核空间 信号驱动IO模型：不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号，然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过信号通知应用进程数据准备好后的可读状态，应用用户进程收到信号之后，立刻调用读写操作。异步IO模型：前面提到的阻塞、非阻塞、信号驱动、多路复用IO模型，在数据从内核复制到应用缓冲区的时候，都是阻塞的，因此都不算是真正的异步。而异步IO可以实现IO全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是立即返回的不是处理结果，而是表示类似提交成功的意思。等内核数据准备好，将数据拷贝到用户缓冲区，发送信号通知用户进程IO操作执行完毕。 事件处理模型服务器程序通常需要处理三类事件：I&#x2F;O 事件、信号及定时事件。随着网络设计模式的兴起，Reactor和Proactor事件处理模式应运而生。同步IO模型通常用于实现Reactor模式，异步IO模型则用于实现Proactor模式。Reactor模式：Reactor模式要求主线程（I&#x2F;O 处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。使用同步I&#x2F;O模型（以epoll_wait为例）实现的Reactor模式的工作流程是： 主线程往epoll内核事件表中注册socket上的读就绪事件。 主线程调用epoll_wait等待socket上有数据可读。 当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 主线程调用epoll_wait等待socket可写。 当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 睡眠在请求队列上的某个工作进程被唤醒，它往socket上写入服务器处理客户请求的结果。 Proactor模式：与Reactor模式不同，Proactor模式将所有I&#x2F;O操作都交给主线程和内核来处理,工作线程仅仅负责业务逻辑。使用异步I&#x2F;O模型（以aio_read和aio_write为例）实现的Proactor 模式的工作流程是： 主线程调用aio_read函数向内核注册socket上的读完成事件,并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)。 主线程继续处理其他逻辑。 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例） 主线程继续处理其他逻辑 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 同步IO模拟Proactor模式由于异步I&#x2F;O并不成熟，实际中使用较少，这里将使用同步I&#x2F;O模拟实现proactor模式。同步I&#x2F;O模型的工作流程如下（epoll_wait为例）： 主线程往epoll内核事件表注册socket上的读就绪事件。 主线程调用epoll_wait等待socket上有数据可读 当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。 主线程调用epoll_wait等待socket可写。 当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。 基础API线程创建函数1int pthread_create(pthread_t *tidp, const pthread_attr_t *attr, (void*)(*start_rtn)(void*), void *arg); 作用：创建新线程； 参数： tidp：指向线程标识符的指针； attr：设置线程属性； start_rtn：线程运行函数的起始地址； arg：运行函数的参数； 返回值：若线程创建成功，则返回0。若线程创建失败，则返回出错编号； 线程分离函数1int pthread_detach(pthread_t thread); 作用：实现线程分离，不再受主线程管理，由系统接任，线程结束后，其退出状态不由其它线程获取，而由自己自动释放。 参数： thread：线程id； 返回值：调用成功返回0，失败返回出错编号； 核心代码分析成员变量12345678int m_thread_number; //线程池中的线程数int m_max_requests; //请求队列中允许的最大请求数pthread_t *m_threads; //描述线程池的数组，其大小为m_thread_numberstd::list&lt;T *&gt; m_workqueue; //请求队列locker m_queuelocker; //保护请求队列的互斥锁sem m_queuestat; //是否有任务需要处理connection_poll *m_connPool; //数据库int m_actor_model; //模型切换 构造函数12345678910111213141516171819202122template &lt;typename T&gt;threadpool&lt;T&gt;::threadpool( int actor_model, connection_poll *connPool, int thread_number, int max_requests) : m_actor_model(actor_model),m_thread_number(thread_number), m_max_requests(max_requests), m_threads(NULL),m_connPool(connPool)&#123; if (thread_number &lt;= 0 || max_requests &lt;= 0) throw std::exception(); m_threads = new pthread_t[m_thread_number]; if (!m_threads) throw std::exception(); for (int i = 0; i &lt; thread_number; ++i) &#123; if (pthread_create(m_threads + i, NULL, worker, this) != 0) &#123; delete[] m_threads; throw std::exception(); &#125; if (pthread_detach(m_threads[i])) &#123; delete[] m_threads; throw std::exception(); &#125; &#125;&#125; 初始化线程池中的线程数、请求队列允许的最大请求数和模型切换标志。建立多个线程，执行work回调函数，同时对线程设置detach属性，此时线程执行完毕后自动回收进程。 公有线程工作函数123456void *threadpool&lt;T&gt;::worker(void *arg)&#123; threadpool *pool = (threadpool *)arg; pool-&gt;run(); return pool;&#125; 调用私有成员函数run。 私有线程工作函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253template &lt;typename T&gt;void threadpool&lt;T&gt;::run()&#123; while (true) &#123; m_queuestat.wait(); m_queuelocker.lock(); if (m_workqueue.empty()) &#123; m_queuelocker.unlock(); continue; &#125; T *request = m_workqueue.front(); m_workqueue.pop_front(); m_queuelocker.unlock(); if (!request) continue; if (1 == m_actor_model) &#123; if (0 == request-&gt;m_state) &#123; if (request-&gt;read_once()) &#123; request-&gt;improv = 1; connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool); request-&gt;process(); &#125; else &#123; request-&gt;improv = 1; request-&gt;timer_flag = 1; &#125; &#125; else &#123; if (request-&gt;write()) &#123; request-&gt;improv = 1; &#125; else &#123; request-&gt;improv = 1; request-&gt;timer_flag = 1; &#125; &#125; &#125; else &#123; connectionRAII mysqlcon(&amp;request-&gt;mysql, m_connPool); request-&gt;process(); &#125; &#125;&#125; m_actor_model为模型切换标志，0表示proactor模式，1表示reactor模式。m_state为读写标志，0为读，1为写。在读状态下时，如果一次性读函数成功，将improv标志置1，从数据库池中取出一个数据库连接，之后执行处理读取http请求函数，如果一次性读函数失败，将timer_flag标志置1，后续从定时器队列中删除此定时器。在写状态下，执行返回http响应函数，如果失败，同样置timer_flag标志为1。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]},{"title":"数据库连接池","slug":"数据库连接池","date":"2022-04-28T10:37:24.000Z","updated":"2022-05-06T15:43:25.159Z","comments":true,"path":"2022/04/28/数据库连接池/","link":"","permalink":"http://example.com/2022/04/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"整体概述池是一种资源的容器，有多种实现方法，如数组、链表、队列等，本项目使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。数据库模块可以分为两部分，其一是数据库连接池的定义和初始化，其二是利用连接池完成登录和注册的校验功能。具体而言，工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还给连接池。","text":"整体概述池是一种资源的容器，有多种实现方法，如数组、链表、队列等，本项目使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。数据库模块可以分为两部分，其一是数据库连接池的定义和初始化，其二是利用连接池完成登录和注册的校验功能。具体而言，工作线程从数据库连接池取得一个连接，访问数据库中的数据，访问完毕后将连接交还给连接池。 基础知识数据库访问流程：当系统需要访问数据库时，首先创建数据库连接，完成数据库操作后，再断开数据库连接。数据库连接池：池是一组资源的集合，在服务器启动之初就被完全创建好并初始化。数据库连接池中的资源就是一组数据库连接，由系统动态地对池中的连接进行使用和释放。当系统开始处理客户请求时，如果它需要相关的资源，可以直接从池中获取，无需动态分配。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。连接池的必要性：如果系统需要频繁访问数据库，则需要频繁创建和断开数据库连接，而这是一个很消耗资源的操作，也容易对数据库造成安全隐患。如果在程序初始化的时候，集中创建多个数据库连接，并把它们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。 基础APImysql_init函数1MYSQL* mysql_init(MYSQL *mysql) 作用：分配或初始化与mysql_real_connect()相适应的MYSQL对象，如果mysql_init()分配了新的对象，应当在程序中调用mysql_close()来关闭连接，以释放对象； 参数：如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址； 返回值：初始化的MYSQL*句柄，如果无足够内存以分配新的对象，返回NULL错误，在内存不足的情况下，返回NULL；mysql_close函数1void mysql_close(MYSQL *mysql) 关闭前面打开的连接，如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄。mysql_real_connect函数12MYSQL* mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 作用：连接数据库引擎，尝试与运行在主机上的MySQL数据库引擎建立连接； 参数： mysql：MYSQL变量； host：MYSQL服务器的地址，如果“host”是NULL或字符串”localhost”，连接将被视为与本地主机的连接； user：登录用户名，如果“user”是NULL或空字符串””，用户将被视为当前用户； passwd：登录密码； db：要连接的数据库，如果db为NULL，连接会将默认的数据库设为该值； port：MYSQL服务器的TCP服务端口； unix_socket：unix连接方式，如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道； clientflag：Mysql运行为ODBC数据库的标记，一般取0； 返回值：如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。mysql_query函数1int mysql_query(MYSQL *mysql, const char *query) 作用：查询数据库中的某一个表内容； 参数： mysql：MYSQL变量； query：由“Null终结的字符串”查询指向的SQL查询，正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号（‘;’）或“\\g”，如果允许多语句执行，字符串可包含多条由分号隔开的语句。mysql_query()不能用于包含二进制数据的查询，应使用mysql_real_query()取而代之（二进制数据可能包含字符‘\\0’，mysql_query()会将该字符解释为查询字符串结束），如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查。 返回值：如果查询成功，返回0。如果出现错误，返回非0值；1int mysql_real_query(MYSQL *mysql, const char *q, unsigned long length) 作用：查询数据库中的某一个表内容； 参数： mysql：MYSQL变量； q：SQL查询语句； length：查询语句的长度； 返回值：如果查询成功，返回0。如果出现错误，返回非0值；mysql_store_result函数1MYSQL_RES* mysql_store_result(MYSQL *mysql) 作用：显示查询数据库中数据表的内容； 说明： 对于成功检索了数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK TABLE等），必须调用mysql_store_result()或mysql_use_result()； 如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查； 如果查询未返回结果集，mysql_store_result()将返回Null指针（例如，如果查询是INSERT语句）； 如果读取结果集失败，mysql_store_result()还会返回Null指针； 一旦调用了mysql_store_result()并获得了不是Null指针的结果，可调用mysql_num_rows()来找出结果集中的行数； 可以调用mysql_fetch_row()来获取结果集中的行，或调用mysql_row_seek()和mysql_row_tell()来获取或设置结果集中的当前行位置； 一旦完成了对结果集的操作，必须调用mysql_free_result()； 返回值：具有多个结果的MYSQL_RES结果集合，如果出现错误，返回NULL；mysql_fetch_row函数1MYSQL_ROW mysql_fetch_row(MYSQL_RES* result) 作用：从结果集中获取下一行； 说明： 在mysql_store_result()之后使用时，如果没有要检索的行，mysql_fetch_row()返回NULL； 在mysql_use_result()之后使用时，如果没有要检索的行或出现了错误，mysql_fetch_row()返回NULL； 行内值的数目由mysql_num_fields(result)给出。如果行中保存了调用mysql_fetch_row()返回的值，将按照row[0]到row[mysql_num_fields(result)-1]，访问这些值的指针； 可以通过调用mysql_fetch_lengths()来获得行中字段值的长度。对于空字段以及包含NULL的字段，长度为0。通过检查字段值的指针，能够区分它们。如果指针为NULL，字段为NULL，否则字段为空； 返回值：下一行的MYSQL_ROW结构。如果没有更多要检索的行或出现了错误，返回NULL；mysql_field_count函数1unsigned int mysql_field_count(MYSQL *mysql) 作用：返回作用在连接上的最近查询的列数； 说明：该函数的正常使用是在mysql_store_result()返回NULL（因而没有结果集指针）时。在这种情况下，可调用mysql_field_count()来判定mysql_store_result()是否应生成非空结果。这样，客户端就能采取恰当的动作，而无需知道查询是否是SELECT（或类似SELECT的）语句； 返回值：表示结果集中列数的无符号整数；核心代码分析成员变量123456789101112string m_url; //主机地址string m_Port; //数据库端口号string m_User; //登录数据库用户名string m_Password; //登录数据库密码string m_Databasename; //使用数据库名int m_close_log; //日志开关locker lock;list&lt;MYSQL*&gt; connList; //连接池sem reserve;int m_MaxConn; //最大连接数int m_CurConn; //当前已使用的连接数int m_FreeConn; //当前空闲的连接数 RAII机制创建、释放资源123456connectionRAII::connectionRAII(MYSQL** SQL,connection_poll* connpool)&#123; *SQL=connpool-&gt;GetConnection(); conRAII=*SQL; poolRAII=connpool;&#125; 将数据库连接的获取与释放通过RAII机制封装，避免手动释放。单例模式创建类对象12345connection_poll* connection_poll::GetInstance()&#123; static connection_poll connPool; return &amp;connPool;&#125; 通过单例模式创建数据库连接池，返回静态成员变量。初始化数据库连接池123456789101112131415161718192021222324252627282930void connection_poll::init(string url,string User,string Password,string Databasename,int Port,int Maxconn,int close_log)&#123; m_url=url; m_Port=Port; m_User=User; m_Password=Password; m_Databasename=Databasename; m_close_log=close_log; for(int i=0;i&lt;Maxconn;i++) &#123; MYSQL* con=NULL; con=mysql_init(con); if(con==NULL) &#123; LOG_ERROR(&quot;MySQL Error&quot;); exit(1); &#125; con=mysql_real_connect(con,url.c_str(),User.c_str(),Password.c_str(),Databasename.c_str(),Port,NULL,0); if(con==NULL) &#123; LOG_ERROR(&quot;MySQL Error&quot;); exit(1); &#125; connList.push_back(con); m_FreeConn++; &#125; reserve=sem(m_FreeConn); m_MaxConn=m_FreeConn;&#125; 创建Maxconn个数据库连接。返回数据库连接1234567891011121314MYSQL* connection_poll::GetConnection()&#123; MYSQL* con=NULL; if(connList.size()==0) return NULL; reserve.wait(); lock.lock(); con=connList.front(); connList.pop_front(); m_FreeConn--; m_CurConn++; lock.unlock(); return con;&#125; 当有请求时，从数据库连接池中返回一个可用连接，原子-1，更新使用和空闲连接数，若连接池内没有连接了，则阻塞等待。释放数据库连接123456789101112bool connection_poll::ReleaseConnection(MYSQL* con)&#123; if(con==NULL) return false; lock.lock(); connList.push_back(con); m_FreeConn++; m_CurConn--; lock.unlock(); reserve.post(); return true;&#125; 释放连接，原子+1。销毁数据库连接池1234567891011121314151617void connection_poll::DestroyPool()&#123; lock.lock(); if(connList.size()&gt;0) &#123; list&lt;MYSQL*&gt;::iterator it; for(it=connList.begin();it!=connList.end();it++) &#123; MYSQL* con=*it; mysql_close(con); &#125; m_CurConn=0; m_FreeConn=0; connList.clear(); &#125; lock.unlock();&#125; 通过迭代器遍历数据库连接池链表，关闭对应数据库连接，清空链表并重置空闲连接和现有连接数量。","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]},{"title":"自封装锁","slug":"自封装锁","date":"2022-04-28T10:37:24.000Z","updated":"2022-05-06T14:07:39.656Z","comments":true,"path":"2022/04/28/自封装锁/","link":"","permalink":"http://example.com/2022/04/28/%E8%87%AA%E5%B0%81%E8%A3%85%E9%94%81/","excerpt":"整体概述对Linux下三种锁（信号量、互斥锁、条件变量）进行封装，将锁的创建和销毁函数封装在类的构造和析构函数中，实现RAII机制。","text":"整体概述对Linux下三种锁（信号量、互斥锁、条件变量）进行封装，将锁的创建和销毁函数封装在类的构造和析构函数中，实现RAII机制。 基础知识信号量信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V)，假设有信号量SV，P操作：如果SV的值大于0，则将其减一，若SV的值为0，则挂起执行；V操作：如果有其他进行因为等待SV而挂起，则唤醒，若没有，则将SV值加一。 互斥锁互斥锁，也成互斥量，可以保护关键代码段，以确保独占式访问，当进入关键代码段，获得互斥锁将其加锁，离开关键代码段，唤醒等待该互斥锁的线程。 条件变量条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。 RAIIRAII是Resource Acquisition Is Initialization的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。在计算机系统中，资源是数量有限且对系统正常运行具有一定作用的元素。比如：网络套接字、互斥锁、文件句柄和内存等等，它们属于系统资源。由于系统的资源是有限的，就好比自然界的石油，铁矿一样，不是取之不尽，用之不竭的，所以，我们在编程使用系统资源时，都必须遵循一个步骤： 申请资源； 使用资源； 释放资源； 第一步和第二步缺一不可，因为资源必须要申请才能使用的，使用完成以后，必须要释放，如果不释放的话，就会造成资源泄漏。但是如果程序很复杂的时候，需要为所有的new分配的内存delete掉，导致极度臃肿，效率下降，更可怕的是，程序的可理解性和可维护性明显降低了，当操作增多时，处理资源释放的代码就会越来越多，越来越乱。如果某一个操作发生了异常而导致释放资源的语句没有被调用，这个时候RAII机制就可以派上用场了。 基础API信号量初始化1int sem_init(sem_t* sem,int pshared,unsigned int value); 作用：初始化信号量； 参数： sem：指向未初始化信号量结构的一个指针； pshared：表示这个信号量是在进程的线程之间共享，还是在进程之间共享； 如果为0，那么这个信号量会在进程的线程之间共享，并且应该位于对所有线程都可见的某个地址； 如果不为0，那么这个信号量将在进程之间共享，并且应该位于共享内存的某个区域； value：指定信号量的初始值； 返回值：成功返回0，失败返回-1； 信号量销毁1int sem_destroy(sem_t *sem); 作用：释放信号量； 参数： sem：通过sem_init()初始化的信号量； 返回值：成功返回0，失败返回-1； 信号量原子-11int sem_wait(sem_t *sem); 作用：是一个原子操作，它的作用是将信号量的值-1，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用sem_wait(),线程将会继续执行，将信号量的值将减到1。如果对一个值为0的信号量调用sem_wait()，这个函数就会地等待直到有其它线程增加了这个值使它不再是0为止； 参数： sem：通过sem_init()初始化的信号量； 返回值：成功返回0，失败返回-1； 信号量原子+11int sem_post(sem_t *sem); 作用：给信号量的值+1，它是一个原子操作，即同时对同一个信号量做+1操作的两个线程是不会冲突的； 参数： sem：通过sem_init()初始化的信号量； 返回值：成功返回0，失败返回-1； 互斥锁初始化1int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *attr); 作用：初始化互斥锁； 参数： mutex：初始化互斥锁的地址； attr：指定了新建互斥锁的属性，如果参数attr为NULL，则使用默认的互斥锁属性； 返回值：调用成功返回0，否则返回一个非0的错误代码； 互斥锁销毁1int pthread_mutex_destroy(pthread_mutex_t *mutex); 作用：释放分配给互斥锁mutex的资源； 参数： mutex：需要销毁的互斥锁地址； 返回值：调用成功返回0，否则返回一个非0的错误代码； 互斥锁上锁1int pthread_mutex_lock(pthread_mutex_t *mutex); 作用：锁住互斥锁变量，如果已被锁住，那么发出调用的线程将被阻塞直到其它进程对mutex解锁； 参数： mutex：需要上锁的互斥锁地址； 返回值：上锁成功返回0，否则返回一个非0的错误代码； 互斥锁解锁1int pthread_mutex_unlock(pthread_mutex_t *mutex); 作用：解除互斥锁，释放mutex引用的互斥锁对象，如果调用pthread_mutex_unlock()时有多个线程被mutex对象阻塞，则互斥锁变为可用时调度策略可确定获取该互斥锁的线程。 参数： mutex：需要解锁的互斥锁地址； 返回值：解锁成功返回0，否则返回一个非0的错误代码； 信号量初始化1int pthread_cond_init(pthread_cond_t *cond,const pthread_condattr_t *attr); 作用：初始化一个条件变量； 参数： cond：需要初始化的条件变量地址； attr：需要指定的条件变量的属性，默认为0； 返回值：初始化成功返回0，否则返回一个非0的错误代码； 信号量销毁1int pthread_cond_destroy(pthread_cond_t *cond); 作用：销毁一个条件变量，释放资源； 参数： cond：需要销毁的条件变量地址； 返回值：销毁成功返回0，否则返回一个非0的错误代码； 信号量wait12int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);int pthread_cond_timedwait(pthread_cond_t *cond,pthread_mutex_t *mutex, const structtimespec * abstime); 作用：线程阻塞在条件变量，直到收到这个条件变量相关的通知。需要传入已经lock的mutex变量。进入wait函数会自动解锁mutex参数指向的互斥锁，并使当前线程阻塞在cond参数指向的条件变量上。当线程被唤醒，退出wait函数时会自动对锁再次进行加锁，成功后返回。被阻塞的线程可以被pthread_cond_signal函数、pthread_cond_broadcast函数唤醒。一般一个条件表达式都是在一个互斥锁的保护下被检查。当条件表达式未被满足时，线程将仍然阻塞在这个条件变量上。当另一个线程改变了条件的值并向条件变量发出信号时，等待在这个条件变量上的一个线程或所有线程被唤醒，接着都试图再次占有相应的互斥锁。 参数： cond：条件变量地址； mutex：互斥锁地址； abstime：指定超时时间，函数到了一定的时间，即使条件未发生也会解除阻塞； 返回值：调用成功返回0，否则返回一个非0的错误代码； 信号量signal12int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond); 作用：这两个函数都会对指定的条件变量产生信号，通知其他线程。唯一一个区别在于当有多个线程阻塞等待条件变量的信号时，这两个函数产生信号后，对其他线程产生的影响会不一样。pthread_cond_signal 会保证至少会唤醒其中一个阻塞在这个条件变量的的线程。pthread_cond_broadcast会唤醒所有阻塞在这个条件变量的线程，适用于那些阻塞的不同线程被唤醒后会处理不同的任务。 参数：cond：条件变量地址； 返回值：调用成功返回0，否者返回一个非0的错误代码； 核心代码分析信号量类具体实现12345678910111213141516171819202122232425262728class sem&#123;private: sem_t m_sem;public: sem() &#123; if(sem_init(&amp;m_sem,0,0)!=0) throw std::exception(); &#125; sem(int num) &#123; if(sem_init(&amp;m_sem,0,num)!=0) throw std::exception(); &#125; ~sem() &#123; sem_destroy(&amp;m_sem); &#125; bool wait() &#123; return sem_wait(&amp;m_sem)==0; &#125; bool post() &#123; return sem_post(&amp;m_sem)==0; &#125;&#125;; 互斥锁类具体实现123456789101112131415161718192021222324252627class locker&#123;private: pthread_mutex_t m_mutex;public: locker() &#123; if(pthread_mutex_init(&amp;m_mutex,NULL)!=0) throw std::exception(); &#125; ~locker() &#123; pthread_mutex_destroy(&amp;m_mutex); &#125; bool lock() &#123; return pthread_mutex_lock(&amp;m_mutex)==0; &#125; bool unlock() &#123; return pthread_mutex_unlock(&amp;m_mutex)==0; &#125; pthread_mutex_t* get() &#123; return &amp;m_mutex; &#125;&#125;; 条件变量类具体实现123456789101112131415161718192021222324252627282930313233class cond&#123;private: pthread_cond_t m_cond;public: cond() &#123; if(pthread_cond_init(&amp;m_cond,NULL)!=0) throw std::exception(); &#125; ~cond() &#123; pthread_cond_destroy(&amp;m_cond); &#125; bool wait(pthread_mutex_t* m_mutex) &#123; int ret=pthread_cond_wait(&amp;m_cond,m_mutex); return ret==0; &#125; bool timewait(pthread_mutex_t* m_mutex,struct timespec t) &#123; int ret=pthread_cond_timedwait(&amp;m_cond,m_mutex,&amp;t); return ret==0; &#125; bool signal() &#123; return pthread_cond_signal(&amp;m_cond)==0; &#125; bool broadcast() &#123; return pthread_cond_broadcast(&amp;m_cond)==0; &#125;&#125;;","categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-27T14:40:30.996Z","updated":"2022-05-06T13:42:07.061Z","comments":true,"path":"2022/04/27/hello-world/","link":"","permalink":"http://example.com/2022/04/27/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"webserver","slug":"webserver","permalink":"http://example.com/categories/webserver/"}],"tags":[{"name":"-学习日志","slug":"学习日志","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"}]}